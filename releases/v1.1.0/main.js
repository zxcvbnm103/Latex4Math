/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MathMemoryGraphPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian14 = require("obsidian");

// src/types/settings.ts
var DEFAULT_SETTINGS = {
  // 基本功能开关
  enableAutoRecognition: true,
  enableGraphView: true,
  enableMathInput: true,
  // 识别设置
  recognitionSensitivity: 0.7,
  customTermsPath: "",
  // 快捷键设置
  shortcutKeys: {
    toggleMathInput: "Ctrl+M",
    openGraphView: "Ctrl+Shift+G",
    recognizeTerms: "Ctrl+Shift+R"
  },
  // 高级设置
  maxTermsPerNote: 100,
  autoSaveInterval: 5e3,
  // 5秒
  enableDebugMode: false,
  // 图谱设置
  graphLayout: "force",
  nodeSize: { min: 10, max: 50 },
  showLabels: true,
  // LaTeX设置
  latexRenderer: "obsidian",
  customLatexCommands: {}
};
var SettingsValidator = class {
  /**
   * 验证设置对象的有效性
   */
  static validate(settings) {
    const errors = [];
    const warnings = [];
    if (settings.recognitionSensitivity !== void 0) {
      if (settings.recognitionSensitivity < 0.1 || settings.recognitionSensitivity > 1) {
        errors.push("\u8BC6\u522B\u654F\u611F\u5EA6\u5FC5\u987B\u57280.1\u52301.0\u4E4B\u95F4");
      }
    }
    if (settings.nodeSize) {
      if (settings.nodeSize.min >= settings.nodeSize.max) {
        errors.push("\u8282\u70B9\u6700\u5C0F\u5C3A\u5BF8\u5FC5\u987B\u5C0F\u4E8E\u6700\u5927\u5C3A\u5BF8");
      }
      if (settings.nodeSize.min < 5 || settings.nodeSize.max > 100) {
        warnings.push("\u5EFA\u8BAE\u8282\u70B9\u5C3A\u5BF8\u57285\u5230100\u4E4B\u95F4");
      }
    }
    if (settings.autoSaveInterval !== void 0) {
      if (settings.autoSaveInterval < 1e3) {
        warnings.push("\u81EA\u52A8\u4FDD\u5B58\u95F4\u9694\u8FC7\u77ED\u53EF\u80FD\u5F71\u54CD\u6027\u80FD");
      }
    }
    if (settings.maxTermsPerNote !== void 0) {
      if (settings.maxTermsPerNote < 10) {
        warnings.push("\u6BCF\u4E2A\u7B14\u8BB0\u7684\u6700\u5927\u672F\u8BED\u6570\u91CF\u8FC7\u5C11\u53EF\u80FD\u5F71\u54CD\u529F\u80FD");
      }
      if (settings.maxTermsPerNote > 1e3) {
        warnings.push("\u6BCF\u4E2A\u7B14\u8BB0\u7684\u6700\u5927\u672F\u8BED\u6570\u91CF\u8FC7\u591A\u53EF\u80FD\u5F71\u54CD\u6027\u80FD");
      }
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * 合并设置，确保所有必需字段都存在
   */
  static merge(userSettings) {
    return {
      ...DEFAULT_SETTINGS,
      ...userSettings,
      // 确保嵌套对象正确合并
      shortcutKeys: {
        ...DEFAULT_SETTINGS.shortcutKeys,
        ...userSettings.shortcutKeys || {}
      },
      nodeSize: {
        ...DEFAULT_SETTINGS.nodeSize,
        ...userSettings.nodeSize || {}
      },
      customLatexCommands: {
        ...DEFAULT_SETTINGS.customLatexCommands,
        ...userSettings.customLatexCommands || {}
      }
    };
  }
};

// src/core/MainController.ts
var import_obsidian8 = require("obsidian");

// src/types/index.ts
var MathCategory = /* @__PURE__ */ ((MathCategory2) => {
  MathCategory2["ALGEBRA"] = "\u4EE3\u6570";
  MathCategory2["CALCULUS"] = "\u5FAE\u79EF\u5206";
  MathCategory2["GEOMETRY"] = "\u51E0\u4F55";
  MathCategory2["STATISTICS"] = "\u7EDF\u8BA1";
  MathCategory2["LINEAR_ALGEBRA"] = "\u7EBF\u6027\u4EE3\u6570";
  MathCategory2["DISCRETE_MATH"] = "\u79BB\u6563\u6570\u5B66";
  MathCategory2["NUMBER_THEORY"] = "\u6570\u8BBA";
  MathCategory2["TOPOLOGY"] = "\u62D3\u6251\u5B66";
  MathCategory2["ANALYSIS"] = "\u6570\u5B66\u5206\u6790";
  MathCategory2["PROBABILITY"] = "\u6982\u7387\u8BBA";
  MathCategory2["SET_THEORY"] = "\u96C6\u5408\u8BBA";
  MathCategory2["LOGIC"] = "\u903B\u8F91";
  return MathCategory2;
})(MathCategory || {});

// src/recognition/ChineseMathDictionary.ts
var ChineseMathDictionary = class {
  constructor() {
    this.terms = /* @__PURE__ */ new Map();
    this.categoryIndex = /* @__PURE__ */ new Map();
    this.aliasIndex = /* @__PURE__ */ new Map();
    // 别名到主术语的映射
    this.isInitialized = false;
  }
  /**
   * 初始化词典，加载内置术语
   */
  async initialize() {
    console.log("ChineseMathDictionary: \u521D\u59CB\u5316\u4E2D\u6587\u6570\u5B66\u672F\u8BED\u8BCD\u5178...");
    try {
      await this.loadBuiltinTerms();
      this.buildCategoryIndex();
      this.buildAliasIndex();
      this.isInitialized = true;
      console.log(`ChineseMathDictionary: \u8BCD\u5178\u521D\u59CB\u5316\u5B8C\u6210\uFF0C\u5171\u52A0\u8F7D ${this.terms.size} \u4E2A\u672F\u8BED`);
    } catch (error) {
      console.error("ChineseMathDictionary: \u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 添加术语到词典
   */
  async addTerm(term) {
    if (!term.id) {
      term.id = this.generateTermId(term.chineseName);
    }
    const now = /* @__PURE__ */ new Date();
    if (!term.createdAt) {
      term.createdAt = now;
    }
    term.updatedAt = now;
    this.terms.set(term.chineseName, term);
    this.addToCategory(term.category, term.chineseName);
    this.updateAliasIndex(term);
    console.log(`ChineseMathDictionary: \u6DFB\u52A0\u672F\u8BED ${term.chineseName}`);
  }
  /**
   * 查找术语
   */
  async findTerm(termName) {
    let term = this.terms.get(termName);
    if (term) {
      return term;
    }
    const mainTermName = this.aliasIndex.get(termName);
    if (mainTermName) {
      return this.terms.get(mainTermName) || null;
    }
    return null;
  }
  /**
   * 查找相似术语
   */
  async findSimilarTerms(query, maxResults = 5) {
    const results = [];
    Array.from(this.terms.entries()).forEach(([termName, term]) => {
      const score = this.calculateSimilarity(query, termName);
      if (score > 0.3) {
        results.push({ term, score });
      }
    });
    results.sort((a, b) => b.score - a.score);
    return results.slice(0, maxResults).map((r) => r.term);
  }
  /**
   * 按分类获取术语
   */
  async getTermsByCategory(category) {
    const termNames = this.categoryIndex.get(category) || /* @__PURE__ */ new Set();
    const terms = [];
    Array.from(termNames).forEach((termName) => {
      const term = this.terms.get(termName);
      if (term) {
        terms.push(term);
      }
    });
    return terms;
  }
  /**
   * 搜索术语
   */
  async searchTerms(query) {
    const results = [];
    const queryLower = query.toLowerCase();
    Array.from(this.terms.entries()).forEach(([termName, term]) => {
      if (termName.includes(query)) {
        results.push(term);
        return;
      }
      if (term.englishName && term.englishName.toLowerCase().includes(queryLower)) {
        results.push(term);
        return;
      }
      if (term.definition && term.definition.includes(query)) {
        results.push(term);
        return;
      }
      for (const alias of term.aliases) {
        if (alias.includes(query)) {
          results.push(term);
          break;
        }
      }
    });
    return results;
  }
  /**
   * 获取所有术语
   */
  async getAllTerms() {
    return Array.from(this.terms.values());
  }
  /**
   * 重新加载词典
   */
  async reload() {
    this.terms.clear();
    this.categoryIndex.clear();
    this.aliasIndex.clear();
    this.isInitialized = false;
    await this.initialize();
  }
  /**
   * 获取词典统计信息
   */
  getStatistics() {
    const categoryCounts = /* @__PURE__ */ new Map();
    Array.from(this.categoryIndex.entries()).forEach(([category, termSet]) => {
      categoryCounts.set(category, termSet.size);
    });
    return {
      totalTerms: this.terms.size,
      categoryCounts
    };
  }
  /**
   * 加载内置术语
   */
  async loadBuiltinTerms() {
    const builtinTerms = [
      // 代数
      { chineseName: "\u51FD\u6570", englishName: "function", category: "\u4EE3\u6570" /* ALGEBRA */, latexCode: "f(x)", aliases: ["\u6620\u5C04"] },
      { chineseName: "\u65B9\u7A0B", englishName: "equation", category: "\u4EE3\u6570" /* ALGEBRA */, latexCode: "ax + b = 0", aliases: ["\u7B49\u5F0F"] },
      { chineseName: "\u4E0D\u7B49\u5F0F", englishName: "inequality", category: "\u4EE3\u6570" /* ALGEBRA */, latexCode: "a > b", aliases: [] },
      { chineseName: "\u591A\u9879\u5F0F", englishName: "polynomial", category: "\u4EE3\u6570" /* ALGEBRA */, latexCode: "a_n x^n + ... + a_1 x + a_0", aliases: [] },
      { chineseName: "\u56E0\u5F0F\u5206\u89E3", englishName: "factorization", category: "\u4EE3\u6570" /* ALGEBRA */, latexCode: "ab = c", aliases: ["\u5206\u89E3\u56E0\u5F0F"] },
      // 微积分
      { chineseName: "\u5BFC\u6570", englishName: "derivative", category: "\u5FAE\u79EF\u5206" /* CALCULUS */, latexCode: "f'(x)", aliases: ["\u5FAE\u5206"] },
      { chineseName: "\u79EF\u5206", englishName: "integral", category: "\u5FAE\u79EF\u5206" /* CALCULUS */, latexCode: "\\int f(x) dx", aliases: [] },
      { chineseName: "\u6781\u9650", englishName: "limit", category: "\u5FAE\u79EF\u5206" /* CALCULUS */, latexCode: "\\lim_{x \\to a} f(x)", aliases: [] },
      { chineseName: "\u8FDE\u7EED", englishName: "continuous", category: "\u5FAE\u79EF\u5206" /* CALCULUS */, latexCode: "\\lim_{x \\to a} f(x) = f(a)", aliases: ["\u8FDE\u7EED\u6027"] },
      { chineseName: "\u5FAE\u5206\u65B9\u7A0B", englishName: "differential equation", category: "\u5FAE\u79EF\u5206" /* CALCULUS */, latexCode: "y' = f(x, y)", aliases: [] },
      // 几何
      { chineseName: "\u4E09\u89D2\u5F62", englishName: "triangle", category: "\u51E0\u4F55" /* GEOMETRY */, latexCode: "\\triangle ABC", aliases: [] },
      { chineseName: "\u5706", englishName: "circle", category: "\u51E0\u4F55" /* GEOMETRY */, latexCode: "x^2 + y^2 = r^2", aliases: ["\u5706\u5F62"] },
      { chineseName: "\u76F4\u7EBF", englishName: "line", category: "\u51E0\u4F55" /* GEOMETRY */, latexCode: "y = kx + b", aliases: ["\u7EBF\u6BB5"] },
      { chineseName: "\u89D2\u5EA6", englishName: "angle", category: "\u51E0\u4F55" /* GEOMETRY */, latexCode: "\\angle ABC", aliases: ["\u89D2"] },
      { chineseName: "\u9762\u79EF", englishName: "area", category: "\u51E0\u4F55" /* GEOMETRY */, latexCode: "S", aliases: [] },
      // 线性代数
      { chineseName: "\u77E9\u9635", englishName: "matrix", category: "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, latexCode: "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}", aliases: [] },
      { chineseName: "\u5411\u91CF", englishName: "vector", category: "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, latexCode: "\\vec{v}", aliases: ["\u77E2\u91CF"] },
      { chineseName: "\u884C\u5217\u5F0F", englishName: "determinant", category: "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, latexCode: "\\det(A)", aliases: [] },
      { chineseName: "\u7279\u5F81\u503C", englishName: "eigenvalue", category: "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, latexCode: "\\lambda", aliases: [] },
      { chineseName: "\u7279\u5F81\u5411\u91CF", englishName: "eigenvector", category: "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, latexCode: "\\vec{v}", aliases: [] },
      // 统计学
      { chineseName: "\u5E73\u5747\u6570", englishName: "mean", category: "\u7EDF\u8BA1" /* STATISTICS */, latexCode: "\\bar{x}", aliases: ["\u5747\u503C", "\u7B97\u672F\u5E73\u5747\u6570"] },
      { chineseName: "\u65B9\u5DEE", englishName: "variance", category: "\u7EDF\u8BA1" /* STATISTICS */, latexCode: "\\sigma^2", aliases: [] },
      { chineseName: "\u6807\u51C6\u5DEE", englishName: "standard deviation", category: "\u7EDF\u8BA1" /* STATISTICS */, latexCode: "\\sigma", aliases: [] },
      { chineseName: "\u6982\u7387", englishName: "probability", category: "\u6982\u7387\u8BBA" /* PROBABILITY */, latexCode: "P(A)", aliases: [] },
      { chineseName: "\u671F\u671B", englishName: "expectation", category: "\u6982\u7387\u8BBA" /* PROBABILITY */, latexCode: "E[X]", aliases: ["\u6570\u5B66\u671F\u671B"] },
      // 数论
      { chineseName: "\u8D28\u6570", englishName: "prime number", category: "\u6570\u8BBA" /* NUMBER_THEORY */, latexCode: "p", aliases: ["\u7D20\u6570"] },
      { chineseName: "\u5408\u6570", englishName: "composite number", category: "\u6570\u8BBA" /* NUMBER_THEORY */, latexCode: "n", aliases: [] },
      { chineseName: "\u6700\u5927\u516C\u7EA6\u6570", englishName: "greatest common divisor", category: "\u6570\u8BBA" /* NUMBER_THEORY */, latexCode: "\\gcd(a, b)", aliases: ["\u6700\u5927\u516C\u56E0\u6570"] },
      { chineseName: "\u6700\u5C0F\u516C\u500D\u6570", englishName: "least common multiple", category: "\u6570\u8BBA" /* NUMBER_THEORY */, latexCode: "\\text{lcm}(a, b)", aliases: [] },
      // 数学分析
      { chineseName: "\u5B9E\u6570", englishName: "real number", category: "\u6570\u5B66\u5206\u6790" /* ANALYSIS */, latexCode: "\\mathbb{R}", aliases: [] },
      { chineseName: "\u590D\u6570", englishName: "complex number", category: "\u6570\u5B66\u5206\u6790" /* ANALYSIS */, latexCode: "\\mathbb{C}", aliases: [] },
      { chineseName: "\u5E8F\u5217", englishName: "sequence", category: "\u6570\u5B66\u5206\u6790" /* ANALYSIS */, latexCode: "\\{a_n\\}", aliases: ["\u6570\u5217"] },
      { chineseName: "\u7EA7\u6570", englishName: "series", category: "\u6570\u5B66\u5206\u6790" /* ANALYSIS */, latexCode: "\\sum_{n=1}^{\\infty} a_n", aliases: [] }
    ];
    for (const termData of builtinTerms) {
      const term = {
        id: this.generateTermId(termData.chineseName),
        chineseName: termData.chineseName,
        englishName: termData.englishName,
        category: termData.category,
        latexCode: termData.latexCode,
        definition: termData.definition,
        aliases: termData.aliases || [],
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      await this.addTerm(term);
    }
  }
  /**
   * 构建分类索引
   */
  buildCategoryIndex() {
    this.categoryIndex.clear();
    for (const term of this.terms.values()) {
      this.addToCategory(term.category, term.chineseName);
    }
  }
  /**
   * 构建别名索引
   */
  buildAliasIndex() {
    this.aliasIndex.clear();
    for (const term of this.terms.values()) {
      this.updateAliasIndex(term);
    }
  }
  /**
   * 添加术语到分类
   */
  addToCategory(category, termName) {
    if (!this.categoryIndex.has(category)) {
      this.categoryIndex.set(category, /* @__PURE__ */ new Set());
    }
    this.categoryIndex.get(category).add(termName);
  }
  /**
   * 更新别名索引
   */
  updateAliasIndex(term) {
    for (const alias of term.aliases) {
      this.aliasIndex.set(alias, term.chineseName);
    }
  }
  /**
   * 生成术语ID
   */
  generateTermId(chineseName) {
    return `term_${chineseName}_${Date.now()}`;
  }
  /**
   * 计算字符串相似度
   */
  calculateSimilarity(str1, str2) {
    const len1 = str1.length;
    const len2 = str2.length;
    if (len1 === 0) return len2 === 0 ? 1 : 0;
    if (len2 === 0) return 0;
    const matrix = [];
    for (let i = 0; i <= len1; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= len2; j++) {
      matrix[0][j] = j;
    }
    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          // 删除
          matrix[i][j - 1] + 1,
          // 插入
          matrix[i - 1][j - 1] + cost
          // 替换
        );
      }
    }
    const distance = matrix[len1][len2];
    const maxLen = Math.max(len1, len2);
    return 1 - distance / maxLen;
  }
};

// src/recognition/TextScanner.ts
var TextScanner = class {
  constructor(dictionary) {
    this.chineseCharRegex = /[\u4e00-\u9fff]/;
    this.mathContextRegex = /[=+\-*/^()[\]{}\\∫∑∏∆∇∂∞±≤≥≠≈∈∉⊂⊃∪∩]/;
    this.dictionary = dictionary;
  }
  /**
   * 扫描文本识别数学术语
   */
  async scanText(text) {
    const recognizedTerms = [];
    try {
      const allTerms = await this.dictionary.getAllTerms();
      const sortedTerms = allTerms.sort((a, b) => b.chineseName.length - a.chineseName.length);
      const matchedPositions = /* @__PURE__ */ new Set();
      for (const term of sortedTerms) {
        const matches = this.findTermMatches(text, term.chineseName, matchedPositions);
        for (const match of matches) {
          const confidence = this.calculateConfidence(text, match, term.chineseName);
          const recognizedTerm = {
            text: term.chineseName,
            startIndex: match.start,
            endIndex: match.end,
            confidence,
            category: term.category,
            suggestedLatex: term.latexCode
          };
          recognizedTerms.push(recognizedTerm);
          for (let i = match.start; i < match.end; i++) {
            matchedPositions.add(i);
          }
        }
        for (const alias of term.aliases) {
          const aliasMatches = this.findTermMatches(text, alias, matchedPositions);
          for (const match of aliasMatches) {
            const confidence = this.calculateConfidence(text, match, alias);
            const recognizedTerm = {
              text: alias,
              startIndex: match.start,
              endIndex: match.end,
              confidence: confidence * 0.9,
              // 别名置信度稍低
              category: term.category,
              suggestedLatex: term.latexCode
            };
            recognizedTerms.push(recognizedTerm);
            for (let i = match.start; i < match.end; i++) {
              matchedPositions.add(i);
            }
          }
        }
      }
      recognizedTerms.sort((a, b) => a.startIndex - b.startIndex);
      console.log(`TextScanner: \u626B\u63CF\u5B8C\u6210\uFF0C\u8BC6\u522B\u5230 ${recognizedTerms.length} \u4E2A\u672F\u8BED`);
      return recognizedTerms;
    } catch (error) {
      console.error("TextScanner: \u6587\u672C\u626B\u63CF\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 查找术语匹配
   */
  findTermMatches(text, termName, excludePositions) {
    const matches = [];
    let searchIndex = 0;
    while (searchIndex < text.length) {
      const index = text.indexOf(termName, searchIndex);
      if (index === -1) break;
      const endIndex = index + termName.length;
      let hasOverlap = false;
      for (let i = index; i < endIndex; i++) {
        if (excludePositions.has(i)) {
          hasOverlap = true;
          break;
        }
      }
      if (!hasOverlap && this.isValidMatch(text, index, endIndex, termName)) {
        matches.push({ start: index, end: endIndex });
      }
      searchIndex = index + 1;
    }
    return matches;
  }
  /**
   * 验证匹配是否有效
   */
  isValidMatch(text, startIndex, endIndex, termName) {
    const beforeChar = startIndex > 0 ? text[startIndex - 1] : "";
    const afterChar = endIndex < text.length ? text[endIndex] : "";
    if (this.chineseCharRegex.test(beforeChar) && this.chineseCharRegex.test(afterChar)) {
      const extendedBefore = startIndex > 1 ? text.substring(startIndex - 2, startIndex) : "";
      const extendedAfter = endIndex < text.length - 1 ? text.substring(endIndex, endIndex + 2) : "";
      if (this.looksLikeLongerTerm(extendedBefore + termName + extendedAfter)) {
        return false;
      }
    }
    return true;
  }
  /**
   * 检查是否看起来像更长的术语
   */
  looksLikeLongerTerm(text) {
    const mathKeywords = ["\u5B9A\u7406", "\u516C\u5F0F", "\u65B9\u6CD5", "\u7B97\u6CD5", "\u6027\u8D28", "\u6CD5\u5219", "\u539F\u7406"];
    for (const keyword of mathKeywords) {
      if (text.includes(keyword)) {
        return true;
      }
    }
    return false;
  }
  /**
   * 计算识别置信度
   */
  calculateConfidence(text, match, termName) {
    let confidence = 0.6;
    const contextBefore = text.substring(Math.max(0, match.start - 20), match.start);
    const contextAfter = text.substring(match.end, Math.min(text.length, match.end + 20));
    const fullContext = contextBefore + contextAfter;
    if (this.hasMathContext(fullContext)) {
      confidence += 0.2;
    }
    if (this.isInLatexEnvironment(text, match.start, match.end)) {
      confidence += 0.15;
    }
    if (this.isInEmphasisContext(text, match.start, match.end)) {
      confidence += 0.1;
    }
    if (this.isInListContext(contextBefore)) {
      confidence += 0.05;
    }
    if (termName.length >= 3) {
      confidence += 0.05;
    }
    return Math.min(1, Math.max(0.1, confidence));
  }
  /**
   * 检查是否有数学上下文
   */
  hasMathContext(context) {
    if (this.mathContextRegex.test(context)) {
      return true;
    }
    const mathKeywords = [
      "\u516C\u5F0F",
      "\u5B9A\u7406",
      "\u8BC1\u660E",
      "\u8BA1\u7B97",
      "\u6C42\u89E3",
      "\u63A8\u5BFC",
      "\u5B9A\u4E49",
      "\u6027\u8D28",
      "\u6CD5\u5219",
      "\u539F\u7406",
      "\u65B9\u6CD5",
      "\u7B97\u6CD5",
      "\u89E3\u6CD5"
    ];
    for (const keyword of mathKeywords) {
      if (context.includes(keyword)) {
        return true;
      }
    }
    return false;
  }
  /**
   * 检查是否在LaTeX环境中
   */
  isInLatexEnvironment(text, start, end) {
    const beforeText = text.substring(0, start);
    const afterText = text.substring(end);
    const dollarsBefore = (beforeText.match(/\$/g) || []).length;
    const dollarsAfter = (afterText.match(/\$/g) || []).length;
    return dollarsBefore % 2 === 1 || text.substring(start - 10, start).includes("\\begin{");
  }
  /**
   * 检查是否在强调上下文中
   */
  isInEmphasisContext(text, start, end) {
    const beforeText = text.substring(Math.max(0, start - 5), start);
    const afterText = text.substring(end, Math.min(text.length, end + 5));
    const emphasisPatterns = ["**", "*", "__", "_", "==", "~~"];
    for (const pattern of emphasisPatterns) {
      if (beforeText.includes(pattern) || afterText.includes(pattern)) {
        return true;
      }
    }
    if (beforeText.includes("#") || beforeText.includes("\n#")) {
      return true;
    }
    return false;
  }
  /**
   * 检查是否在列表上下文中
   */
  isInListContext(contextBefore) {
    const lines = contextBefore.split("\n");
    const lastLine = lines[lines.length - 1] || "";
    return /^\s*[-*+]\s/.test(lastLine) || /^\s*\d+\.\s/.test(lastLine);
  }
  /**
   * 预测术语类别
   */
  predictCategory(context) {
    const categoryKeywords = /* @__PURE__ */ new Map([
      ["\u5FAE\u79EF\u5206" /* CALCULUS */, ["\u5BFC\u6570", "\u79EF\u5206", "\u6781\u9650", "\u5FAE\u5206", "\u8FDE\u7EED"]],
      ["\u4EE3\u6570" /* ALGEBRA */, ["\u65B9\u7A0B", "\u51FD\u6570", "\u591A\u9879\u5F0F", "\u56E0\u5F0F", "\u4E0D\u7B49\u5F0F"]],
      ["\u51E0\u4F55" /* GEOMETRY */, ["\u4E09\u89D2", "\u5706", "\u76F4\u7EBF", "\u89D2\u5EA6", "\u9762\u79EF", "\u4F53\u79EF"]],
      ["\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, ["\u77E9\u9635", "\u5411\u91CF", "\u884C\u5217\u5F0F", "\u7279\u5F81"]],
      ["\u7EDF\u8BA1" /* STATISTICS */, ["\u5E73\u5747", "\u65B9\u5DEE", "\u6807\u51C6\u5DEE", "\u6982\u7387", "\u7EDF\u8BA1"]],
      ["\u6570\u8BBA" /* NUMBER_THEORY */, ["\u8D28\u6570", "\u7D20\u6570", "\u516C\u7EA6\u6570", "\u516C\u500D\u6570"]],
      ["\u6570\u5B66\u5206\u6790" /* ANALYSIS */, ["\u5B9E\u6570", "\u590D\u6570", "\u5E8F\u5217", "\u7EA7\u6570", "\u6536\u655B"]]
    ]);
    Array.from(categoryKeywords.entries()).forEach(([category, keywords]) => {
      for (const keyword of keywords) {
        if (context.includes(keyword)) {
          return category;
        }
      }
    });
    return "\u4EE3\u6570" /* ALGEBRA */;
  }
};

// src/recognition/TermMarker.ts
var import_obsidian = require("obsidian");
var TermMarker = class {
  constructor(app) {
    this.markedTerms = /* @__PURE__ */ new Map();
    // 文件路径 -> 术语集合
    this.styleElement = null;
    this.app = app;
    this.initializeStyles();
  }
  /**
   * 在文件中标记术语
   */
  async markTerms(file, terms) {
    var _a;
    try {
      const filePath = file.path;
      if (!this.markedTerms.has(filePath)) {
        this.markedTerms.set(filePath, /* @__PURE__ */ new Set());
      }
      const markedSet = this.markedTerms.get(filePath);
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView || ((_a = activeView.file) == null ? void 0 : _a.path) !== filePath) {
        console.log("TermMarker: \u5F53\u524D\u6587\u4EF6\u4E0D\u662F\u6D3B\u52A8\u7F16\u8F91\u5668\uFF0C\u8DF3\u8FC7\u6807\u8BB0");
        return;
      }
      const editor = activeView.editor;
      const content = editor.getValue();
      const sortedTerms = terms.sort((a, b) => b.startIndex - a.startIndex);
      for (const term of sortedTerms) {
        if (markedSet.has(term.text)) {
          continue;
        }
        const actualText = content.substring(term.startIndex, term.endIndex);
        if (actualText !== term.text) {
          console.warn(`TermMarker: \u672F\u8BED\u4F4D\u7F6E\u5DF2\u53D8\u5316: ${term.text}`);
          continue;
        }
        await this.addTermHighlight(editor, term);
        markedSet.add(term.text);
      }
      console.log(`TermMarker: \u5728 ${file.name} \u4E2D\u6807\u8BB0\u4E86 ${terms.length} \u4E2A\u672F\u8BED`);
    } catch (error) {
      console.error("TermMarker: \u6807\u8BB0\u672F\u8BED\u5931\u8D25:", error);
    }
  }
  /**
   * 清除文件中的术语标记
   */
  async clearMarks(file) {
    var _a;
    const filePath = file.path;
    if (this.markedTerms.has(filePath)) {
      this.markedTerms.delete(filePath);
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView && ((_a = activeView.file) == null ? void 0 : _a.path) === filePath) {
      await this.clearEditorHighlights(activeView.editor);
    }
    console.log(`TermMarker: \u6E05\u9664\u4E86 ${file.name} \u4E2D\u7684\u672F\u8BED\u6807\u8BB0`);
  }
  /**
   * 切换术语标记显示
   */
  toggleTermMarking(enabled) {
    if (this.styleElement) {
      this.styleElement.disabled = !enabled;
    }
    console.log(`TermMarker: \u672F\u8BED\u6807\u8BB0\u663E\u793A ${enabled ? "\u542F\u7528" : "\u7981\u7528"}`);
  }
  /**
   * 获取术语的颜色
   */
  getTermColor(category) {
    const colorMap = /* @__PURE__ */ new Map([
      ["\u4EE3\u6570" /* ALGEBRA */, "#ff6b6b"],
      // 红色
      ["\u5FAE\u79EF\u5206" /* CALCULUS */, "#4ecdc4"],
      // 青色
      ["\u51E0\u4F55" /* GEOMETRY */, "#45b7d1"],
      // 蓝色
      ["\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */, "#96ceb4"],
      // 绿色
      ["\u7EDF\u8BA1" /* STATISTICS */, "#feca57"],
      // 黄色
      ["\u6982\u7387\u8BBA" /* PROBABILITY */, "#ff9ff3"],
      // 粉色
      ["\u6570\u8BBA" /* NUMBER_THEORY */, "#54a0ff"],
      // 深蓝
      ["\u6570\u5B66\u5206\u6790" /* ANALYSIS */, "#5f27cd"],
      // 紫色
      ["\u62D3\u6251\u5B66" /* TOPOLOGY */, "#00d2d3"],
      // 青绿
      ["\u79BB\u6563\u6570\u5B66" /* DISCRETE_MATH */, "#ff6348"]
      // 橙红
    ]);
    return colorMap.get(category) || "#666666";
  }
  /**
   * 添加术语高亮
   */
  async addTermHighlight(editor, term) {
    try {
      const startPos = this.indexToPosition(editor, term.startIndex);
      const endPos = this.indexToPosition(editor, term.endIndex);
      if (!startPos || !endPos) {
        console.warn("TermMarker: \u65E0\u6CD5\u8F6C\u6362\u672F\u8BED\u4F4D\u7F6E");
        return;
      }
      const className = `math-term-${term.category.replace(/\s+/g, "-").toLowerCase()}`;
      if (editor.addHighlight) {
        editor.addHighlight(startPos, endPos, className);
      } else {
        await this.addDOMHighlight(editor, startPos, endPos, className, term);
      }
    } catch (error) {
      console.error("TermMarker: \u6DFB\u52A0\u9AD8\u4EAE\u5931\u8D25:", error);
    }
  }
  /**
   * 添加DOM高亮（备用方案）
   */
  async addDOMHighlight(editor, startPos, endPos, className, term) {
    const editorElement = editor.containerEl;
    if (!editorElement) return;
    const textNodes = this.findTextNodes(editorElement);
    for (const node of textNodes) {
      if (node.textContent && node.textContent.includes(term.text)) {
        const parent = node.parentElement;
        if (parent && !parent.classList.contains("math-term-highlight")) {
          const span = document.createElement("span");
          span.className = `math-term-highlight ${className}`;
          span.title = `${term.text} (${term.category}) - \u7F6E\u4FE1\u5EA6: ${(term.confidence * 100).toFixed(1)}%`;
          const newContent = node.textContent.replace(
            term.text,
            `<span class="${className}">${term.text}</span>`
          );
          if (newContent !== node.textContent) {
            parent.innerHTML = parent.innerHTML.replace(
              term.text,
              `<span class="math-term-highlight ${className}" title="${span.title}">${term.text}</span>`
            );
            break;
          }
        }
      }
    }
  }
  /**
   * 查找文本节点
   */
  findTextNodes(element) {
    const textNodes = [];
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null
    );
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    return textNodes;
  }
  /**
   * 清除编辑器高亮
   */
  async clearEditorHighlights(editor) {
    try {
      if (editor.clearHighlights) {
        editor.clearHighlights();
      } else {
        const editorElement = editor.containerEl;
        if (editorElement) {
          const highlights = editorElement.querySelectorAll(".math-term-highlight");
          highlights.forEach((highlight) => {
            const parent = highlight.parentNode;
            if (parent) {
              parent.replaceChild(document.createTextNode(highlight.textContent || ""), highlight);
            }
          });
        }
      }
    } catch (error) {
      console.error("TermMarker: \u6E05\u9664\u9AD8\u4EAE\u5931\u8D25:", error);
    }
  }
  /**
   * 将字符索引转换为编辑器位置
   */
  indexToPosition(editor, index) {
    try {
      const content = editor.getValue();
      if (index < 0 || index > content.length) {
        return null;
      }
      let line = 0;
      let ch = 0;
      for (let i = 0; i < index; i++) {
        if (content[i] === "\n") {
          line++;
          ch = 0;
        } else {
          ch++;
        }
      }
      return { line, ch };
    } catch (error) {
      console.error("TermMarker: \u4F4D\u7F6E\u8F6C\u6362\u5931\u8D25:", error);
      return null;
    }
  }
  /**
   * 初始化样式
   */
  initializeStyles() {
    this.styleElement = document.createElement("style");
    this.styleElement.id = "math-memory-graph-term-styles";
    const css = `
            .math-term-highlight {
                position: relative;
                cursor: pointer;
                border-radius: 3px;
                padding: 1px 2px;
                margin: 0 1px;
                transition: all 0.2s ease;
            }
            
            .math-term-highlight:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }
            
            /* \u4E0D\u540C\u7C7B\u522B\u7684\u989C\u8272 */
            .math-term-\u4EE3\u6570 {
                background-color: rgba(255, 107, 107, 0.2);
                border-bottom: 2px solid #ff6b6b;
            }
            
            .math-term-\u5FAE\u79EF\u5206 {
                background-color: rgba(78, 205, 196, 0.2);
                border-bottom: 2px solid #4ecdc4;
            }
            
            .math-term-\u51E0\u4F55 {
                background-color: rgba(69, 183, 209, 0.2);
                border-bottom: 2px solid #45b7d1;
            }
            
            .math-term-\u7EBF\u6027\u4EE3\u6570 {
                background-color: rgba(150, 206, 180, 0.2);
                border-bottom: 2px solid #96ceb4;
            }
            
            .math-term-\u7EDF\u8BA1 {
                background-color: rgba(254, 202, 87, 0.2);
                border-bottom: 2px solid #feca57;
            }
            
            .math-term-\u6982\u7387\u8BBA {
                background-color: rgba(255, 159, 243, 0.2);
                border-bottom: 2px solid #ff9ff3;
            }
            
            .math-term-\u6570\u8BBA {
                background-color: rgba(84, 160, 255, 0.2);
                border-bottom: 2px solid #54a0ff;
            }
            
            .math-term-\u6570\u5B66\u5206\u6790 {
                background-color: rgba(95, 39, 205, 0.2);
                border-bottom: 2px solid #5f27cd;
            }
            
            .math-term-\u62D3\u6251\u5B66 {
                background-color: rgba(0, 210, 211, 0.2);
                border-bottom: 2px solid #00d2d3;
            }
            
            .math-term-\u79BB\u6563\u6570\u5B66 {
                background-color: rgba(255, 99, 72, 0.2);
                border-bottom: 2px solid #ff6348;
            }
            
            /* \u7F6E\u4FE1\u5EA6\u6307\u793A\u5668 */
            .math-term-highlight::after {
                content: '';
                position: absolute;
                top: -2px;
                right: -2px;
                width: 6px;
                height: 6px;
                border-radius: 50%;
                background-color: #4CAF50;
                opacity: 0.8;
            }
            
            .math-term-highlight[data-confidence="low"]::after {
                background-color: #FF9800;
            }
            
            .math-term-highlight[data-confidence="very-low"]::after {
                background-color: #F44336;
            }
            
            /* \u6697\u8272\u4E3B\u9898\u9002\u914D */
            .theme-dark .math-term-highlight {
                background-color: rgba(255, 255, 255, 0.1);
            }
            
            .theme-dark .math-term-highlight:hover {
                background-color: rgba(255, 255, 255, 0.15);
            }
        `;
    this.styleElement.textContent = css;
    document.head.appendChild(this.styleElement);
    console.log("TermMarker: \u6837\u5F0F\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 清理资源
   */
  cleanup() {
    if (this.styleElement) {
      document.head.removeChild(this.styleElement);
      this.styleElement = null;
    }
    this.markedTerms.clear();
    console.log("TermMarker: \u8D44\u6E90\u6E05\u7406\u5B8C\u6210");
  }
};

// src/recognition/UsageTracker.ts
var UsageTracker = class {
  constructor() {
    this.usageStats = /* @__PURE__ */ new Map();
    this.sessionStats = /* @__PURE__ */ new Map();
    this.isInitialized = false;
    this.saveTimer = null;
  }
  /**
   * 初始化使用频率跟踪器
   */
  async initialize() {
    console.log("UsageTracker: \u521D\u59CB\u5316\u4F7F\u7528\u9891\u7387\u8DDF\u8E2A\u5668...");
    try {
      await this.loadUsageData();
      this.startPeriodicSave();
      this.isInitialized = true;
      console.log("UsageTracker: \u4F7F\u7528\u9891\u7387\u8DDF\u8E2A\u5668\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("UsageTracker: \u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 记录术语使用
   */
  async recordUsage(termName, context) {
    if (!this.isInitialized) {
      console.warn("UsageTracker: \u8DDF\u8E2A\u5668\u672A\u521D\u59CB\u5316");
      return;
    }
    try {
      if (!this.usageStats.has(termName)) {
        this.usageStats.set(termName, {
          termName,
          totalCount: 0,
          dailyCount: /* @__PURE__ */ new Map(),
          lastUsed: /* @__PURE__ */ new Date(),
          firstUsed: /* @__PURE__ */ new Date(),
          contexts: []
        });
      }
      const usageData = this.usageStats.get(termName);
      usageData.totalCount++;
      usageData.lastUsed = /* @__PURE__ */ new Date();
      const today = this.getDateKey(/* @__PURE__ */ new Date());
      const currentDailyCount = usageData.dailyCount.get(today) || 0;
      usageData.dailyCount.set(today, currentDailyCount + 1);
      if (context) {
        usageData.contexts.unshift(context);
        if (usageData.contexts.length > 10) {
          usageData.contexts = usageData.contexts.slice(0, 10);
        }
      }
      const sessionCount = this.sessionStats.get(termName) || 0;
      this.sessionStats.set(termName, sessionCount + 1);
      console.log(`UsageTracker: \u8BB0\u5F55\u672F\u8BED\u4F7F\u7528 - ${termName} (\u603B\u8BA1: ${usageData.totalCount})`);
    } catch (error) {
      console.error("UsageTracker: \u8BB0\u5F55\u4F7F\u7528\u5931\u8D25:", error);
    }
  }
  /**
   * 初始化术语
   */
  async initializeTerm(termName) {
    if (!this.usageStats.has(termName)) {
      this.usageStats.set(termName, {
        termName,
        totalCount: 0,
        dailyCount: /* @__PURE__ */ new Map(),
        lastUsed: /* @__PURE__ */ new Date(),
        firstUsed: /* @__PURE__ */ new Date(),
        contexts: []
      });
      console.log(`UsageTracker: \u521D\u59CB\u5316\u672F\u8BED - ${termName}`);
    }
  }
  /**
   * 获取术语使用次数
   */
  getUsageCount(termName) {
    const usageData = this.usageStats.get(termName);
    return usageData ? usageData.totalCount : 0;
  }
  /**
   * 获取术语今日使用次数
   */
  getTodayUsageCount(termName) {
    const usageData = this.usageStats.get(termName);
    if (!usageData) return 0;
    const today = this.getDateKey(/* @__PURE__ */ new Date());
    return usageData.dailyCount.get(today) || 0;
  }
  /**
   * 获取会话使用次数
   */
  getSessionUsageCount(termName) {
    return this.sessionStats.get(termName) || 0;
  }
  /**
   * 获取使用统计
   */
  async getStatistics() {
    const stats = /* @__PURE__ */ new Map();
    Array.from(this.usageStats.entries()).forEach(([termName, usageData]) => {
      stats.set(termName, usageData.totalCount);
    });
    return stats;
  }
  /**
   * 获取详细统计信息
   */
  async getDetailedStatistics() {
    const totalTerms = this.usageStats.size;
    const totalUsages = Array.from(this.usageStats.values()).reduce((sum, data) => sum + data.totalCount, 0);
    const mostUsedTerms = Array.from(this.usageStats.entries()).sort(([, a], [, b]) => b.totalCount - a.totalCount).slice(0, 10).map(([termName, data]) => ({
      termName,
      count: data.totalCount,
      lastUsed: data.lastUsed
    }));
    const today = this.getDateKey(/* @__PURE__ */ new Date());
    const todayActiveTerms = Array.from(this.usageStats.entries()).filter(([, data]) => data.dailyCount.has(today)).map(([termName, data]) => ({
      termName,
      count: data.dailyCount.get(today),
      totalCount: data.totalCount
    })).sort((a, b) => b.count - a.count);
    const recentlyUsedTerms = Array.from(this.usageStats.entries()).sort(([, a], [, b]) => b.lastUsed.getTime() - a.lastUsed.getTime()).slice(0, 10).map(([termName, data]) => ({
      termName,
      lastUsed: data.lastUsed,
      totalCount: data.totalCount
    }));
    return {
      totalTerms,
      totalUsages,
      mostUsedTerms,
      todayActiveTerms,
      recentlyUsedTerms,
      sessionStats: new Map(this.sessionStats)
    };
  }
  /**
   * 获取术语使用趋势
   */
  async getUsageTrend(termName, days = 7) {
    const usageData = this.usageStats.get(termName);
    if (!usageData) return [];
    const trend = [];
    const today = /* @__PURE__ */ new Date();
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateKey = this.getDateKey(date);
      const count = usageData.dailyCount.get(dateKey) || 0;
      trend.push({
        date: new Date(date),
        count,
        dateKey
      });
    }
    return trend;
  }
  /**
   * 清理旧数据
   */
  async cleanupOldData(daysToKeep = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
    const cutoffKey = this.getDateKey(cutoffDate);
    let cleanedCount = 0;
    for (const usageData of this.usageStats.values()) {
      const keysToDelete = [];
      for (const [dateKey] of usageData.dailyCount) {
        if (dateKey < cutoffKey) {
          keysToDelete.push(dateKey);
        }
      }
      for (const key of keysToDelete) {
        usageData.dailyCount.delete(key);
        cleanedCount++;
      }
    }
    console.log(`UsageTracker: \u6E05\u7406\u4E86 ${cleanedCount} \u6761\u65E7\u6570\u636E`);
    await this.saveUsageData();
  }
  /**
   * 重置会话统计
   */
  resetSessionStats() {
    this.sessionStats.clear();
    console.log("UsageTracker: \u4F1A\u8BDD\u7EDF\u8BA1\u5DF2\u91CD\u7F6E");
  }
  /**
   * 加载使用数据
   */
  async loadUsageData() {
    try {
      const savedData = localStorage.getItem("math-memory-graph-usage-stats");
      if (savedData) {
        const parsed = JSON.parse(savedData);
        for (const [termName, data] of Object.entries(parsed)) {
          const usageData = data;
          this.usageStats.set(termName, {
            termName,
            totalCount: usageData.totalCount || 0,
            dailyCount: new Map(Object.entries(usageData.dailyCount || {})),
            lastUsed: new Date(usageData.lastUsed),
            firstUsed: new Date(usageData.firstUsed),
            contexts: usageData.contexts || []
          });
        }
        console.log(`UsageTracker: \u52A0\u8F7D\u4E86 ${this.usageStats.size} \u4E2A\u672F\u8BED\u7684\u4F7F\u7528\u6570\u636E`);
      }
    } catch (error) {
      console.error("UsageTracker: \u52A0\u8F7D\u4F7F\u7528\u6570\u636E\u5931\u8D25:", error);
    }
  }
  /**
   * 保存使用数据
   */
  async saveUsageData() {
    try {
      const dataToSave = {};
      for (const [termName, usageData] of this.usageStats) {
        dataToSave[termName] = {
          termName: usageData.termName,
          totalCount: usageData.totalCount,
          dailyCount: Object.fromEntries(usageData.dailyCount),
          lastUsed: usageData.lastUsed.toISOString(),
          firstUsed: usageData.firstUsed.toISOString(),
          contexts: usageData.contexts
        };
      }
      localStorage.setItem("math-memory-graph-usage-stats", JSON.stringify(dataToSave));
      console.log("UsageTracker: \u4F7F\u7528\u6570\u636E\u5DF2\u4FDD\u5B58");
    } catch (error) {
      console.error("UsageTracker: \u4FDD\u5B58\u4F7F\u7528\u6570\u636E\u5931\u8D25:", error);
    }
  }
  /**
   * 启动定期保存
   */
  startPeriodicSave() {
    this.saveTimer = setInterval(async () => {
      await this.saveUsageData();
    }, 5 * 60 * 1e3);
  }
  /**
   * 获取日期键
   */
  getDateKey(date) {
    return date.toISOString().split("T")[0];
  }
  /**
   * 清理资源
   */
  cleanup() {
    if (this.saveTimer) {
      clearInterval(this.saveTimer);
      this.saveTimer = null;
    }
    this.saveUsageData();
    console.log("UsageTracker: \u8D44\u6E90\u6E05\u7406\u5B8C\u6210");
  }
};

// src/recognition/TermRecognitionEngine.ts
var TermRecognitionEngine = class {
  constructor(app) {
    this.isInitialized = false;
    this.app = app;
    this.dictionary = new ChineseMathDictionary();
    this.textScanner = new TextScanner(this.dictionary);
    this.termMarker = new TermMarker(app);
    this.usageTracker = new UsageTracker();
  }
  /**
   * 初始化识别引擎
   */
  async initialize() {
    console.log("TermRecognitionEngine: \u521D\u59CB\u5316\u672F\u8BED\u8BC6\u522B\u5F15\u64CE...");
    try {
      await this.dictionary.initialize();
      await this.usageTracker.initialize();
      this.registerEventHandlers();
      this.isInitialized = true;
      console.log("TermRecognitionEngine: \u672F\u8BED\u8BC6\u522B\u5F15\u64CE\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("TermRecognitionEngine: \u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 识别文本中的数学术语
   */
  async recognizeTerms(text) {
    if (!this.isInitialized) {
      throw new Error("\u672F\u8BED\u8BC6\u522B\u5F15\u64CE\u672A\u521D\u59CB\u5316");
    }
    try {
      const recognizedTerms = await this.textScanner.scanText(text);
      for (const term of recognizedTerms) {
        await this.usageTracker.recordUsage(term.text);
      }
      const adjustedTerms = this.adjustConfidenceByUsage(recognizedTerms);
      console.log(`TermRecognitionEngine: \u8BC6\u522B\u5230 ${adjustedTerms.length} \u4E2A\u672F\u8BED`);
      return adjustedTerms;
    } catch (error) {
      console.error("TermRecognitionEngine: \u672F\u8BED\u8BC6\u522B\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 添加自定义术语
   */
  async addCustomTerm(term) {
    try {
      const validation = await this.validateTerm(term.chineseName);
      if (!validation.isValid) {
        throw new Error(`\u672F\u8BED\u9A8C\u8BC1\u5931\u8D25: ${validation.errors.join(", ")}`);
      }
      await this.dictionary.addTerm(term);
      await this.usageTracker.initializeTerm(term.chineseName);
      console.log(`TermRecognitionEngine: \u6210\u529F\u6DFB\u52A0\u81EA\u5B9A\u4E49\u672F\u8BED: ${term.chineseName}`);
    } catch (error) {
      console.error("TermRecognitionEngine: \u6DFB\u52A0\u81EA\u5B9A\u4E49\u672F\u8BED\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 更新术语词典
   */
  async updateTermDictionary() {
    try {
      await this.dictionary.reload();
      console.log("TermRecognitionEngine: \u672F\u8BED\u8BCD\u5178\u66F4\u65B0\u5B8C\u6210");
    } catch (error) {
      console.error("TermRecognitionEngine: \u672F\u8BED\u8BCD\u5178\u66F4\u65B0\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 验证术语
   */
  async validateTerm(term) {
    const errors = [];
    const warnings = [];
    const suggestions = [];
    if (!term || term.trim().length === 0) {
      errors.push("\u672F\u8BED\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (term.length > 50) {
      warnings.push("\u672F\u8BED\u957F\u5EA6\u8FC7\u957F\uFF0C\u5EFA\u8BAE\u7B80\u5316");
    }
    const existingTerm = await this.dictionary.findTerm(term);
    if (existingTerm) {
      warnings.push("\u672F\u8BED\u5DF2\u5B58\u5728\u4E8E\u8BCD\u5178\u4E2D");
      suggestions.push(`\u73B0\u6709\u672F\u8BED: ${existingTerm.chineseName} (${existingTerm.category})`);
    }
    const similarTerms = await this.dictionary.findSimilarTerms(term);
    if (similarTerms.length > 0) {
      suggestions.push(`\u76F8\u4F3C\u672F\u8BED: ${similarTerms.map((t) => t.chineseName).join(", ")}`);
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      suggestions
    };
  }
  /**
   * 在当前文档中标记术语
   */
  async markTermsInCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      console.warn("TermRecognitionEngine: \u6CA1\u6709\u6D3B\u52A8\u6587\u6863");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const recognizedTerms = await this.recognizeTerms(content);
      if (recognizedTerms.length > 0) {
        await this.termMarker.markTerms(activeFile, recognizedTerms);
        console.log(`TermRecognitionEngine: \u5728\u6587\u6863 ${activeFile.name} \u4E2D\u6807\u8BB0\u4E86 ${recognizedTerms.length} \u4E2A\u672F\u8BED`);
      }
    } catch (error) {
      console.error("TermRecognitionEngine: \u6807\u8BB0\u672F\u8BED\u5931\u8D25:", error);
    }
  }
  /**
   * 自动创建术语双链
   */
  async createTermLinks(file, terms) {
    try {
      const content = await this.app.vault.read(file);
      let modifiedContent = content;
      const sortedTerms = terms.sort((a, b) => b.startIndex - a.startIndex);
      for (const term of sortedTerms) {
        const beforeText = content.substring(Math.max(0, term.startIndex - 2), term.startIndex);
        const afterText = content.substring(term.endIndex, Math.min(content.length, term.endIndex + 2));
        if (beforeText.includes("[[") || afterText.includes("]]")) {
          continue;
        }
        const linkText = `[[${term.text}]]`;
        modifiedContent = modifiedContent.substring(0, term.startIndex) + linkText + modifiedContent.substring(term.endIndex);
      }
      if (modifiedContent !== content) {
        await this.app.vault.modify(file, modifiedContent);
        console.log(`TermRecognitionEngine: \u5728 ${file.name} \u4E2D\u521B\u5EFA\u4E86 ${terms.length} \u4E2A\u672F\u8BED\u94FE\u63A5`);
      }
    } catch (error) {
      console.error("TermRecognitionEngine: \u521B\u5EFA\u672F\u8BED\u94FE\u63A5\u5931\u8D25:", error);
    }
  }
  /**
   * 获取术语使用统计
   */
  async getUsageStatistics() {
    return await this.usageTracker.getStatistics();
  }
  /**
   * 根据使用频率调整置信度
   */
  adjustConfidenceByUsage(terms) {
    return terms.map((term) => {
      const usageCount = this.usageTracker.getUsageCount(term.text);
      const usageBoost = Math.min(0.2, usageCount * 0.01);
      return {
        ...term,
        confidence: Math.min(1, term.confidence + usageBoost)
      };
    });
  }
  /**
   * 注册事件处理器
   */
  registerEventHandlers() {
    this.app.vault.on("modify", async (file) => {
      if (file.extension === "md") {
        setTimeout(async () => {
          await this.processFileChange(file);
        }, 1e3);
      }
    });
    this.app.vault.on("create", async (file) => {
      if (file.extension === "md") {
        await this.processFileChange(file);
      }
    });
    console.log("TermRecognitionEngine: \u4E8B\u4EF6\u5904\u7406\u5668\u6CE8\u518C\u5B8C\u6210");
  }
  /**
   * 处理文件变更
   */
  async processFileChange(file) {
    try {
      const content = await this.app.vault.read(file);
      const recognizedTerms = await this.recognizeTerms(content);
      if (recognizedTerms.length > 0) {
        this.app.workspace.trigger("math-memory:terms-recognized", {
          file,
          terms: recognizedTerms
        });
      }
    } catch (error) {
      console.error("TermRecognitionEngine: \u5904\u7406\u6587\u4EF6\u53D8\u66F4\u5931\u8D25:", error);
    }
  }
  /**
   * 清理资源
   */
  cleanup() {
    console.log("TermRecognitionEngine: \u6E05\u7406\u8D44\u6E90");
  }
};

// src/latex/NeuralLatexConverter.ts
var import_obsidian2 = require("obsidian");
var NeuralLatexConverter = class extends import_obsidian2.Component {
  constructor(app) {
    super();
    this.model = null;
    this.isModelLoaded = false;
    this.app = app;
    this.fallbackConverter = new FallbackConverter();
    this.initializeModel();
  }
  /**
   * 初始化神经网络模型
   */
  async initializeModel() {
    try {
      this.model = new MathTermNeuralModel();
      await this.model.loadModel();
      this.isModelLoaded = true;
      console.log("\u2705 \u795E\u7ECF\u7F51\u7EDCLaTeX\u8F6C\u6362\u6A21\u578B\u52A0\u8F7D\u6210\u529F");
    } catch (error) {
      console.warn("\u26A0\uFE0F \u795E\u7ECF\u7F51\u7EDC\u6A21\u578B\u52A0\u8F7D\u5931\u8D25\uFF0C\u4F7F\u7528\u5907\u7528\u65B9\u6848:", error);
      this.isModelLoaded = false;
    }
  }
  /**
   * 转换术语为LaTeX代码 - 混合策略
   */
  async convertTerm(term) {
    const normalizedTerm = term.trim();
    const ruleResult = this.fallbackConverter.convertWithRules(normalizedTerm);
    if (ruleResult.confidence > 0.9) {
      return this.buildResult(normalizedTerm, ruleResult.latex, ruleResult.confidence, "rule-based");
    }
    if (this.isModelLoaded && this.model) {
      try {
        const modelResult = await this.model.predict(normalizedTerm);
        if (modelResult.confidence > 0.7) {
          return this.buildResult(normalizedTerm, modelResult.latex, modelResult.confidence, "neural-model");
        }
      } catch (error) {
        console.warn("\u795E\u7ECF\u7F51\u7EDC\u9884\u6D4B\u5931\u8D25:", error);
      }
    }
    const inferredResult = this.fallbackConverter.inferLatex(normalizedTerm);
    return this.buildResult(normalizedTerm, inferredResult.latex, inferredResult.confidence, "inference");
  }
  /**
   * 构建LaTeX转换结果
   */
  async buildResult(originalTerm, latexCode, confidence, source) {
    const renderedHtml = await this.renderLatexToHtml(latexCode);
    const alternatives = this.getAlternativeLatex(originalTerm);
    return {
      originalTerm,
      latexCode,
      renderedHtml,
      confidence,
      alternatives,
      source
      // 添加来源信息
    };
  }
  /**
   * 渲染LaTeX代码为HTML元素
   */
  async renderLatex(latexCode) {
    const container = document.createElement("div");
    container.className = "math-latex-container";
    try {
      const mathEl = container.createDiv("math");
      mathEl.textContent = latexCode;
      await this.renderWithObsidianMath(mathEl, latexCode);
    } catch (error) {
      console.warn("LaTeX\u6E32\u67D3\u5931\u8D25\uFF0C\u4F7F\u7528\u6587\u672C\u663E\u793A:", error);
      container.textContent = `LaTeX: ${latexCode}`;
      container.className += " latex-render-error";
    }
    return container;
  }
  /**
   * 使用Obsidian的数学渲染引擎
   */
  async renderWithObsidianMath(element, latexCode) {
    const mathMarkdown = `$${latexCode}$`;
    try {
      await import_obsidian2.MarkdownRenderer.renderMarkdown(mathMarkdown, element, "", this);
    } catch (error) {
      element.innerHTML = `<code class="language-latex">${latexCode}</code>`;
    }
  }
  /**
   * 验证LaTeX代码的有效性
   */
  async validateLatex(latexCode) {
    return this.fallbackConverter.validateLatex(latexCode);
  }
  /**
   * 自定义术语的LaTeX代码
   */
  async customizeLatex(termId, latexCode) {
    const validation = await this.validateLatex(latexCode);
    if (!validation.isValid) {
      throw new Error(`\u65E0\u6548\u7684LaTeX\u4EE3\u7801: ${validation.errors.join(", ")}`);
    }
    this.fallbackConverter.addCustomMapping(termId, latexCode);
    if (this.isModelLoaded && this.model) {
      await this.model.addCustomTerm(termId, latexCode);
    }
  }
  /**
   * 获取LaTeX模板
   */
  async getLatexTemplates(category) {
    return this.fallbackConverter.getTemplates(category);
  }
  /**
   * 复制LaTeX代码到剪贴板
   */
  async copyLatexToClipboard(latexCode, format = "inline") {
    let formattedLatex;
    if (format === "inline") {
      formattedLatex = `$${latexCode}$`;
    } else {
      formattedLatex = `$$
${latexCode}
$$`;
    }
    try {
      await navigator.clipboard.writeText(formattedLatex);
    } catch (error) {
      this.fallbackCopyToClipboard(formattedLatex);
    }
  }
  /**
   * 获取替代LaTeX表示
   */
  getAlternativeLatex(term) {
    return this.fallbackConverter.getAlternatives(term);
  }
  /**
   * 渲染LaTeX为HTML字符串
   */
  async renderLatexToHtml(latexCode) {
    const tempElement = await this.renderLatex(latexCode);
    return tempElement.outerHTML;
  }
  /**
   * 降级的剪贴板复制方法
   */
  fallbackCopyToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.left = "-999999px";
    textArea.style.top = "-999999px";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      document.execCommand("copy");
    } finally {
      document.body.removeChild(textArea);
    }
  }
  /**
   * 获取模型状态信息
   */
  getModelStatus() {
    var _a;
    return {
      loaded: this.isModelLoaded,
      type: this.isModelLoaded ? "neural-hybrid" : "rule-based-fallback",
      version: (_a = this.model) == null ? void 0 : _a.getVersion()
    };
  }
  /**
   * 组件卸载时的清理
   */
  onunload() {
    if (this.model) {
      this.model.dispose();
    }
    this.fallbackConverter.dispose();
  }
};
var MathTermNeuralModel = class {
  constructor() {
    this.modelWeights = null;
    this.version = "1.0.0";
    this.vocabulary = this.buildVocabulary();
    this.reverseVocab = this.buildReverseVocabulary();
  }
  /**
   * 加载预训练模型
   */
  async loadModel() {
    this.modelWeights = await this.loadMockModel();
    console.log("\u795E\u7ECF\u7F51\u7EDC\u6A21\u578B\u52A0\u8F7D\u5B8C\u6210");
  }
  /**
   * 预测中文术语对应的LaTeX
   */
  async predict(chineseTerm) {
    const inputTokens = this.tokenizeChinese(chineseTerm);
    const prediction = this.mockInference(inputTokens, chineseTerm);
    return prediction;
  }
  /**
   * 添加自定义术语（增量学习）
   */
  async addCustomTerm(term, latex) {
    console.log(`\u6DFB\u52A0\u81EA\u5B9A\u4E49\u672F\u8BED: ${term} \u2192 ${latex}`);
  }
  /**
   * 获取模型版本
   */
  getVersion() {
    return this.version;
  }
  /**
   * 释放模型资源
   */
  dispose() {
    this.modelWeights = null;
    console.log("\u795E\u7ECF\u7F51\u7EDC\u6A21\u578B\u8D44\u6E90\u5DF2\u91CA\u653E");
  }
  /**
   * 构建词汇表
   */
  buildVocabulary() {
    const chineseVocab = /* @__PURE__ */ new Map([
      ["<PAD>", 0],
      ["<UNK>", 1],
      ["\u5BFC", 2],
      ["\u6570", 3],
      ["\u504F", 4],
      ["\u79EF", 5],
      ["\u5206", 6],
      ["\u77E9", 7],
      ["\u9635", 8],
      ["\u5411", 9],
      ["\u91CF", 10],
      ["\u6781", 11],
      ["\u9650", 12],
      ["\u6C42", 13],
      ["\u548C", 14],
      ["\u4E58", 15],
      ["\u79EF", 16],
      ["\u6839", 17],
      ["\u53F7", 18],
      ["\u89D2", 19],
      ["\u5EA6", 20],
      ["\u6982", 21],
      ["\u7387", 22],
      ["\u671F", 23],
      ["\u671B", 24],
      ["\u65B9", 25],
      ["\u5DEE", 26],
      ["\u6807", 27],
      ["\u51C6", 28],
      ["\u5C5E", 29],
      ["\u4E8E", 30],
      ["\u5305", 31],
      ["\u542B", 32],
      ["\u5E76", 33],
      ["\u96C6", 34],
      ["\u4EA4", 35],
      ["\u7A7A", 36],
      ["\u5E73", 37],
      ["\u884C", 38],
      ["\u5782", 39],
      ["\u76F4", 40],
      ["\u76F8", 41],
      ["\u4F3C", 42],
      ["\u5168", 43],
      ["\u7B49", 44],
      ["\u4E09", 45],
      ["\u89D2", 46],
      ["\u5F62", 47],
      ["\u5706", 48],
      ["\u963F", 49],
      ["\u5C14", 50],
      ["\u6CD5", 51],
      ["\u8D1D", 52],
      ["\u5854", 53],
      ["\u6D3E", 54]
    ]);
    const latexVocab = /* @__PURE__ */ new Map([
      ["<PAD>", 0],
      ["<UNK>", 1],
      ["\\", 2],
      ["frac", 3],
      ["{", 4],
      ["}", 5],
      ["d", 6],
      ["x", 7],
      ["partial", 8],
      ["int", 9],
      ["sum", 10],
      ["prod", 11],
      ["lim", 12],
      ["infty", 13],
      ["sqrt", 14],
      ["vec", 15],
      ["hat", 16],
      ["det", 17],
      ["begin", 18],
      ["end", 19],
      ["pmatrix", 20],
      ["alpha", 21],
      ["beta", 22],
      ["gamma", 23],
      ["delta", 24],
      ["theta", 25],
      ["lambda", 26],
      ["pi", 27],
      ["sigma", 28],
      ["omega", 29],
      ["cdot", 30],
      ["times", 31],
      ["div", 32],
      ["=", 33],
      ["+", 34],
      ["-", 35],
      ["^", 36],
      ["_", 37],
      ["(", 38],
      [")", 39],
      ["a", 40],
      ["b", 41],
      ["c", 42],
      ["f", 43],
      ["g", 44],
      ["h", 45],
      ["i", 46],
      ["j", 47],
      ["n", 48],
      ["y", 49],
      ["z", 50]
    ]);
    return { chinese: chineseVocab, latex: latexVocab };
  }
  /**
   * 构建反向词汇表
   */
  buildReverseVocabulary() {
    const chineseReverse = /* @__PURE__ */ new Map();
    const latexReverse = /* @__PURE__ */ new Map();
    this.vocabulary.chinese.forEach((id, token) => {
      chineseReverse.set(id, token);
    });
    this.vocabulary.latex.forEach((id, token) => {
      latexReverse.set(id, token);
    });
    return { chinese: chineseReverse, latex: latexReverse };
  }
  /**
   * 中文分词
   */
  tokenizeChinese(text) {
    const tokens = [];
    for (const char of text) {
      const tokenId = this.vocabulary.chinese.get(char) || this.vocabulary.chinese.get("<UNK>");
      tokens.push(tokenId);
    }
    return tokens;
  }
  /**
   * 加载模拟模型
   */
  async loadMockModel() {
    await new Promise((resolve) => setTimeout(resolve, 100));
    return {
      encoder_weights: new Array(1e3).fill(0).map(() => Math.random()),
      decoder_weights: new Array(1e3).fill(0).map(() => Math.random()),
      loaded: true
    };
  }
  /**
   * 模拟推理过程
   */
  mockInference(inputTokens, originalTerm) {
    const knownTerms = {
      "\u5BFC\u6570": { latex: "\\frac{d}{dx}", confidence: 0.95 },
      "\u504F\u5BFC\u6570": { latex: "\\frac{\\partial}{\\partial x}", confidence: 0.94 },
      "\u4E8C\u9636\u5BFC\u6570": { latex: "\\frac{d^2}{dx^2}", confidence: 0.93 },
      "\u79EF\u5206": { latex: "\\int", confidence: 0.96 },
      "\u5B9A\u79EF\u5206": { latex: "\\int_{a}^{b}", confidence: 0.95 },
      "\u4E0D\u5B9A\u79EF\u5206": { latex: "\\int", confidence: 0.94 },
      "\u4E8C\u91CD\u79EF\u5206": { latex: "\\iint", confidence: 0.92 },
      "\u4E09\u91CD\u79EF\u5206": { latex: "\\iiint", confidence: 0.91 },
      "\u77E9\u9635": { latex: "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}", confidence: 0.94 },
      "\u884C\u5217\u5F0F": { latex: "\\det", confidence: 0.96 },
      "\u5411\u91CF": { latex: "\\vec{v}", confidence: 0.95 },
      "\u5355\u4F4D\u5411\u91CF": { latex: "\\hat{u}", confidence: 0.93 },
      "\u6781\u9650": { latex: "\\lim", confidence: 0.96 },
      "\u65E0\u7A77\u5927": { latex: "\\infty", confidence: 0.97 },
      "\u6C42\u548C": { latex: "\\sum", confidence: 0.95 },
      "\u4E58\u79EF": { latex: "\\prod", confidence: 0.94 },
      "\u5206\u6570": { latex: "\\frac{a}{b}", confidence: 0.93 },
      "\u6839\u53F7": { latex: "\\sqrt{x}", confidence: 0.95 },
      "\u5E73\u65B9\u6839": { latex: "\\sqrt{x}", confidence: 0.94 },
      "\u7ACB\u65B9\u6839": { latex: "\\sqrt[3]{x}", confidence: 0.92 },
      "\u6982\u7387": { latex: "P", confidence: 0.94 },
      "\u671F\u671B": { latex: "E[X]", confidence: 0.93 },
      "\u65B9\u5DEE": { latex: "\\text{Var}(X)", confidence: 0.92 },
      "\u6807\u51C6\u5DEE": { latex: "\\sigma", confidence: 0.94 },
      "\u963F\u5C14\u6CD5": { latex: "\\alpha", confidence: 0.96 },
      "\u8D1D\u5854": { latex: "\\beta", confidence: 0.96 },
      "\u4F3D\u9A6C": { latex: "\\gamma", confidence: 0.95 },
      "\u5FB7\u5C14\u5854": { latex: "\\delta", confidence: 0.95 },
      "\u6D3E": { latex: "\\pi", confidence: 0.97 },
      "\u897F\u683C\u739B": { latex: "\\sigma", confidence: 0.95 }
    };
    if (knownTerms[originalTerm]) {
      return knownTerms[originalTerm];
    }
    const similarities = Object.keys(knownTerms).map((term) => ({
      term,
      similarity: this.calculateSimilarity(originalTerm, term),
      result: knownTerms[term]
    }));
    const bestMatch = similarities.reduce(
      (best, current) => current.similarity > best.similarity ? current : best
    );
    if (bestMatch.similarity > 0.6) {
      return {
        latex: bestMatch.result.latex,
        confidence: bestMatch.result.confidence * bestMatch.similarity
      };
    }
    if (originalTerm.includes("\u5BFC\u6570")) {
      return { latex: "\\frac{d}{dx}", confidence: 0.75 };
    }
    if (originalTerm.includes("\u79EF\u5206")) {
      return { latex: "\\int", confidence: 0.75 };
    }
    if (originalTerm.includes("\u77E9\u9635")) {
      return { latex: "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}", confidence: 0.7 };
    }
    if (originalTerm.includes("\u5411\u91CF")) {
      return { latex: "\\vec{v}", confidence: 0.75 };
    }
    return { latex: `\\text{${originalTerm}}`, confidence: 0.3 };
  }
  /**
   * 计算字符串相似度
   */
  calculateSimilarity(str1, str2) {
    const len1 = str1.length;
    const len2 = str2.length;
    const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(null));
    for (let i = 0; i <= len1; i++) matrix[i][0] = i;
    for (let j = 0; j <= len2; j++) matrix[0][j] = j;
    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        if (str1[i - 1] === str2[j - 1]) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    const maxLen = Math.max(len1, len2);
    return maxLen === 0 ? 1 : (maxLen - matrix[len1][len2]) / maxLen;
  }
};
var FallbackConverter = class {
  constructor() {
    this.ruleMapping = /* @__PURE__ */ new Map();
    this.customMapping = /* @__PURE__ */ new Map();
    this.templates = /* @__PURE__ */ new Map();
    this.initializeRuleMapping();
    this.initializeTemplates();
  }
  /**
   * 使用规则进行转换
   */
  convertWithRules(term) {
    const customLatex = this.customMapping.get(term);
    if (customLatex) {
      return { latex: customLatex, confidence: 1 };
    }
    const ruleResult = this.ruleMapping.get(term);
    if (ruleResult) {
      return ruleResult;
    }
    return { latex: "", confidence: 0 };
  }
  /**
   * 智能推断LaTeX
   */
  inferLatex(term) {
    if (term.includes("\u5206\u6570") || term.includes("\u6BD4\u503C")) {
      return { latex: "\\frac{a}{b}", confidence: 0.6 };
    }
    if (term.includes("\u6839\u53F7") || term.includes("\u5E73\u65B9\u6839")) {
      return { latex: "\\sqrt{x}", confidence: 0.6 };
    }
    if (term.includes("\u4E0A\u6807") || term.includes("\u5E42")) {
      return { latex: "x^{n}", confidence: 0.5 };
    }
    if (term.includes("\u4E0B\u6807")) {
      return { latex: "x_{i}", confidence: 0.5 };
    }
    return { latex: `\\text{${term}}`, confidence: 0.3 };
  }
  /**
   * 添加自定义映射
   */
  addCustomMapping(term, latex) {
    this.customMapping.set(term, latex);
  }
  /**
   * 获取替代方案
   */
  getAlternatives(term) {
    const alternatives = {
      "\u5BFC\u6570": ["f'(x)", "\\dot{f}", "Df"],
      "\u79EF\u5206": ["\\iint", "\\iiint", "\\oint"],
      "\u77E9\u9635": ["\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}", "\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}"]
    };
    return alternatives[term] || [];
  }
  /**
   * 获取模板
   */
  getTemplates(category) {
    return this.templates.get(category) || [];
  }
  /**
   * 验证LaTeX
   */
  validateLatex(latexCode) {
    const errors = [];
    const warnings = [];
    const suggestions = [];
    if (!latexCode || latexCode.trim().length === 0) {
      errors.push("LaTeX\u4EE3\u7801\u4E0D\u80FD\u4E3A\u7A7A");
      return { isValid: false, errors, warnings, suggestions };
    }
    const openBraces = (latexCode.match(/\{/g) || []).length;
    const closeBraces = (latexCode.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      errors.push("\u82B1\u62EC\u53F7\u4E0D\u5339\u914D");
    }
    return { isValid: errors.length === 0, errors, warnings, suggestions };
  }
  /**
   * 释放资源
   */
  dispose() {
    this.ruleMapping.clear();
    this.customMapping.clear();
    this.templates.clear();
  }
  /**
   * 初始化规则映射
   */
  initializeRuleMapping() {
    const rules = [
      // 微积分
      ["\u5BFC\u6570", "\\frac{d}{dx}", 1],
      ["\u504F\u5BFC\u6570", "\\frac{\\partial}{\\partial x}", 1],
      ["\u79EF\u5206", "\\int", 1],
      ["\u5B9A\u79EF\u5206", "\\int_{a}^{b}", 1],
      ["\u6781\u9650", "\\lim", 1],
      ["\u65E0\u7A77\u5927", "\\infty", 1],
      // 线性代数
      ["\u77E9\u9635", "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}", 1],
      ["\u5411\u91CF", "\\vec{v}", 1],
      ["\u884C\u5217\u5F0F", "\\det", 1],
      // 基础符号
      ["\u5206\u6570", "\\frac{a}{b}", 1],
      ["\u6839\u53F7", "\\sqrt{x}", 1],
      ["\u6C42\u548C", "\\sum", 1],
      // 希腊字母
      ["\u963F\u5C14\u6CD5", "\\alpha", 1],
      ["\u8D1D\u5854", "\\beta", 1],
      ["\u6D3E", "\\pi", 1]
    ];
    rules.forEach(([term, latex, confidence]) => {
      this.ruleMapping.set(term, { latex, confidence });
    });
  }
  /**
   * 初始化模板
   */
  initializeTemplates() {
  }
};

// src/latex/LaTeXPreviewWidget.ts
var import_obsidian3 = require("obsidian");
var LaTeXPreviewWidget = class extends import_obsidian3.Component {
  constructor(app, converter) {
    super();
    this.isVisible = false;
    this.app = app;
    this.converter = converter;
    this.createWidget();
  }
  /**
   * 创建预览小部件
   */
  createWidget() {
    this.container = document.createElement("div");
    this.container.className = "latex-preview-widget";
    this.container.style.cssText = `
            position: absolute;
            background: var(--background-primary);
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            padding: 12px;
            box-shadow: var(--shadow-s);
            z-index: 1000;
            max-width: 400px;
            display: none;
        `;
    const title = this.container.createDiv("latex-preview-title");
    title.textContent = "LaTeX \u9884\u89C8";
    title.style.cssText = `
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-normal);
            font-size: 14px;
        `;
    this.previewElement = this.container.createDiv("latex-preview-content");
    this.previewElement.style.cssText = `
            min-height: 40px;
            padding: 8px;
            background: var(--background-secondary);
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            margin-bottom: 8px;
        `;
    this.createActionButtons();
    document.body.appendChild(this.container);
  }
  /**
   * 创建操作按钮
   */
  createActionButtons() {
    const buttonContainer = this.container.createDiv("latex-preview-actions");
    buttonContainer.style.cssText = `
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        `;
    const copyInlineBtn = buttonContainer.createEl("button", {
      text: "\u590D\u5236 $...$",
      cls: "mod-cta"
    });
    copyInlineBtn.style.fontSize = "12px";
    copyInlineBtn.onclick = () => this.copyLatex("inline");
    const copyBlockBtn = buttonContainer.createEl("button", {
      text: "\u590D\u5236 $$...$$"
    });
    copyBlockBtn.style.fontSize = "12px";
    copyBlockBtn.onclick = () => this.copyLatex("block");
    const closeBtn = buttonContainer.createEl("button", {
      text: "\xD7"
    });
    closeBtn.style.cssText = `
            font-size: 16px;
            padding: 2px 8px;
            margin-left: 8px;
        `;
    closeBtn.onclick = () => this.hide();
  }
  /**
   * 显示预览小部件
   */
  async show(inputElement, latexCode) {
    this.inputElement = inputElement;
    await this.updatePreview(latexCode);
    this.positionWidget(inputElement);
    this.container.style.display = "block";
    this.isVisible = true;
    this.setupInputListener();
  }
  /**
   * 隐藏预览小部件
   */
  hide() {
    this.container.style.display = "none";
    this.isVisible = false;
    this.removeInputListener();
  }
  /**
   * 更新预览内容
   */
  async updatePreview(latexCode) {
    if (!latexCode || latexCode.trim().length === 0) {
      this.previewElement.innerHTML = '<span style="color: var(--text-muted); font-style: italic;">\u8F93\u5165 LaTeX \u4EE3\u7801\u4EE5\u67E5\u770B\u9884\u89C8</span>';
      return;
    }
    try {
      this.previewElement.innerHTML = "";
      const renderedElement = await this.converter.renderLatex(latexCode);
      this.previewElement.appendChild(renderedElement);
    } catch (error) {
      console.warn("LaTeX\u9884\u89C8\u6E32\u67D3\u5931\u8D25:", error);
      this.previewElement.innerHTML = `
                <span style="color: var(--text-error);">
                    \u6E32\u67D3\u5931\u8D25: ${error.message}
                </span>
            `;
    }
  }
  /**
   * 定位小部件位置
   */
  positionWidget(inputElement) {
    const rect = inputElement.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();
    let left = rect.left;
    let top = rect.bottom + 8;
    if (left + containerRect.width > window.innerWidth) {
      left = window.innerWidth - containerRect.width - 16;
    }
    if (top + containerRect.height > window.innerHeight) {
      top = rect.top - containerRect.height - 8;
    }
    left = Math.max(16, left);
    top = Math.max(16, top);
    this.container.style.left = `${left}px`;
    this.container.style.top = `${top}px`;
  }
  /**
   * 设置输入监听器
   */
  setupInputListener() {
    if (!this.inputElement) return;
    const updatePreview = async () => {
      const latexCode = this.inputElement.value;
      await this.updatePreview(latexCode);
    };
    this.inputElement.addEventListener("input", updatePreview);
    this.inputElement.addEventListener("blur", () => {
      setTimeout(() => {
        if (!this.container.matches(":hover")) {
          this.hide();
        }
      }, 200);
    });
    this.inputElement._latexPreviewListener = updatePreview;
  }
  /**
   * 移除输入监听器
   */
  removeInputListener() {
    if (!this.inputElement) return;
    const listener = this.inputElement._latexPreviewListener;
    if (listener) {
      this.inputElement.removeEventListener("input", listener);
      this.inputElement.removeEventListener("blur", listener);
      delete this.inputElement._latexPreviewListener;
    }
  }
  /**
   * 复制LaTeX代码
   */
  async copyLatex(format) {
    if (!this.inputElement) return;
    const latexCode = this.inputElement.value;
    if (!latexCode) return;
    try {
      await this.converter.copyLatexToClipboard(latexCode, format);
      this.showCopySuccess(format);
    } catch (error) {
      console.error("\u590D\u5236LaTeX\u4EE3\u7801\u5931\u8D25:", error);
      this.showCopyError();
    }
  }
  /**
   * 显示复制成功提示
   */
  showCopySuccess(format) {
    const formatText = format === "inline" ? "$...$" : "$$...$$";
    const toast = document.createElement("div");
    toast.textContent = `\u5DF2\u590D\u5236 ${formatText} \u683C\u5F0F\u5230\u526A\u8D34\u677F`;
    toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
        `;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = "slideOutRight 0.3s ease-in";
      setTimeout(() => {
        document.body.removeChild(toast);
      }, 300);
    }, 3e3);
  }
  /**
   * 显示复制错误提示
   */
  showCopyError() {
    const toast = document.createElement("div");
    toast.textContent = "\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u590D\u5236";
    toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--background-modifier-error);
            color: var(--text-error);
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 10000;
        `;
    document.body.appendChild(toast);
    setTimeout(() => {
      document.body.removeChild(toast);
    }, 3e3);
  }
  /**
   * 检查是否可见
   */
  isShowing() {
    return this.isVisible;
  }
  /**
   * 组件卸载时的清理
   */
  onunload() {
    this.hide();
    this.removeInputListener();
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }
};
var style = document.createElement("style");
style.textContent = `
@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutRight {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

.latex-preview-widget:hover {
    box-shadow: var(--shadow-l);
}

.latex-preview-content .math {
    text-align: center;
    margin: 0;
}

.latex-preview-content .latex-render-error {
    color: var(--text-error);
    font-family: var(--font-monospace);
    font-size: 12px;
}
`;
if (!document.head.querySelector("style[data-latex-preview]")) {
  style.setAttribute("data-latex-preview", "true");
  document.head.appendChild(style);
}

// src/latex/LaTeXCopyHelper.ts
var import_obsidian4 = require("obsidian");
var LaTeXCopyHelper = class {
  constructor(app, converter) {
    this.app = app;
    this.converter = converter;
  }
  /**
   * 为术语元素添加右键菜单
   */
  addContextMenuToTerm(element, term) {
    element.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      this.showTermContextMenu(event, term);
    });
  }
  /**
   * 显示术语的右键菜单
   */
  showTermContextMenu(event, term) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle("\u590D\u5236 LaTeX \u4EE3\u7801 ($...$)").setIcon("copy").onClick(async () => {
        await this.copyTermLatex(term, "inline");
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u590D\u5236 LaTeX \u4EE3\u7801 ($$...$$)").setIcon("copy").onClick(async () => {
        await this.copyTermLatex(term, "block");
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u590D\u5236\u672F\u8BED\u540D\u79F0").setIcon("text").onClick(async () => {
        await this.copyToClipboard(term.chineseName);
        new import_obsidian4.Notice(`\u5DF2\u590D\u5236\u672F\u8BED\u540D\u79F0: ${term.chineseName}`);
      });
    });
    if (term.englishName) {
      menu.addItem((item) => {
        item.setTitle("\u590D\u5236\u82F1\u6587\u540D\u79F0").setIcon("text").onClick(async () => {
          await this.copyToClipboard(term.englishName);
          new import_obsidian4.Notice(`\u5DF2\u590D\u5236\u82F1\u6587\u540D\u79F0: ${term.englishName}`);
        });
      });
    }
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u63D2\u5165\u5230\u5F53\u524D\u4F4D\u7F6E").setIcon("plus").onClick(() => {
        this.insertLatexToEditor(term);
      });
    });
    menu.showAtMouseEvent(event);
  }
  /**
   * 复制术语的LaTeX代码
   */
  async copyTermLatex(term, format) {
    try {
      await this.converter.copyLatexToClipboard(term.latexCode, format);
      const formatText = format === "inline" ? "$...$" : "$$...$$";
      new import_obsidian4.Notice(`\u5DF2\u590D\u5236 ${term.chineseName} \u7684 LaTeX \u4EE3\u7801 (${formatText})`);
    } catch (error) {
      console.error("\u590D\u5236LaTeX\u4EE3\u7801\u5931\u8D25:", error);
      new import_obsidian4.Notice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
    }
  }
  /**
   * 插入LaTeX代码到当前编辑器
   */
  insertLatexToEditor(term) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!activeView) {
      new import_obsidian4.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2AMarkdown\u6587\u4EF6");
      return;
    }
    const editor = activeView.editor;
    const cursor = editor.getCursor();
    const currentLine = editor.getLine(cursor.line);
    const isEmptyLine = currentLine.trim().length === 0;
    let latexText;
    if (isEmptyLine || this.shouldUseBlockFormat(term.latexCode)) {
      latexText = `$$
${term.latexCode}
$$`;
    } else {
      latexText = `$${term.latexCode}$`;
    }
    editor.replaceRange(latexText, cursor);
    if (latexText.startsWith("$$")) {
      editor.setCursor(cursor.line + 1, term.latexCode.length);
    } else {
      editor.setCursor(cursor.line, cursor.ch + latexText.length);
    }
    new import_obsidian4.Notice(`\u5DF2\u63D2\u5165 ${term.chineseName} \u7684 LaTeX \u4EE3\u7801`);
  }
  /**
   * 判断是否应该使用块格式
   */
  shouldUseBlockFormat(latexCode) {
    const blockIndicators = [
      "\\begin{",
      "\\end{",
      "\\frac{",
      "\\int_",
      "\\sum_",
      "\\prod_",
      "\\lim_",
      "\\\\"
      // 换行符
    ];
    return blockIndicators.some((indicator) => latexCode.includes(indicator)) || latexCode.length > 20;
  }
  /**
   * 创建LaTeX快速插入按钮
   */
  createQuickInsertButton(container, term) {
    const button = container.createEl("button", {
      text: "LaTeX",
      cls: "latex-quick-insert-btn"
    });
    button.style.cssText = `
            font-size: 11px;
            padding: 2px 6px;
            margin-left: 8px;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.8;
        `;
    button.addEventListener("mouseenter", () => {
      button.style.opacity = "1";
    });
    button.addEventListener("mouseleave", () => {
      button.style.opacity = "0.8";
    });
    button.addEventListener("click", (event) => {
      event.stopPropagation();
      this.showQuickInsertMenu(event, term);
    });
    return button;
  }
  /**
   * 显示快速插入菜单
   */
  showQuickInsertMenu(event, term) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle("\u63D2\u5165\u5185\u8054\u683C\u5F0F ($...$)").setIcon("plus-circle").onClick(() => {
        this.insertLatexToEditorWithFormat(term, "inline");
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u63D2\u5165\u5757\u683C\u5F0F ($$...$$)").setIcon("plus-square").onClick(() => {
        this.insertLatexToEditorWithFormat(term, "block");
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("\u590D\u5236\u5230\u526A\u8D34\u677F").setIcon("copy").onClick(async () => {
        await this.copyTermLatex(term, "inline");
      });
    });
    menu.showAtMouseEvent(event);
  }
  /**
   * 以指定格式插入LaTeX到编辑器
   */
  insertLatexToEditorWithFormat(term, format) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!activeView) {
      new import_obsidian4.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2AMarkdown\u6587\u4EF6");
      return;
    }
    const editor = activeView.editor;
    const cursor = editor.getCursor();
    let latexText;
    if (format === "block") {
      latexText = `$$
${term.latexCode}
$$`;
    } else {
      latexText = `$${term.latexCode}$`;
    }
    editor.replaceRange(latexText, cursor);
    if (format === "block") {
      editor.setCursor(cursor.line + 1, term.latexCode.length);
    } else {
      editor.setCursor(cursor.line, cursor.ch + latexText.length);
    }
    const formatText = format === "inline" ? "\u5185\u8054" : "\u5757";
    new import_obsidian4.Notice(`\u5DF2\u63D2\u5165 ${term.chineseName} \u7684 LaTeX \u4EE3\u7801 (${formatText}\u683C\u5F0F)`);
  }
  /**
   * 批量复制多个术语的LaTeX代码
   */
  async copyMultipleTermsLatex(terms, format = "inline") {
    if (terms.length === 0) {
      new import_obsidian4.Notice("\u6CA1\u6709\u9009\u62E9\u4EFB\u4F55\u672F\u8BED");
      return;
    }
    try {
      const latexCodes = terms.map((term) => {
        if (format === "block") {
          return `$$
${term.latexCode}
$$`;
        } else {
          return `$${term.latexCode}$`;
        }
      });
      const combinedLatex = latexCodes.join("\n\n");
      await this.copyToClipboard(combinedLatex);
      const formatText = format === "inline" ? "\u5185\u8054" : "\u5757";
      new import_obsidian4.Notice(`\u5DF2\u590D\u5236 ${terms.length} \u4E2A\u672F\u8BED\u7684 LaTeX \u4EE3\u7801 (${formatText}\u683C\u5F0F)`);
    } catch (error) {
      console.error("\u6279\u91CF\u590D\u5236LaTeX\u4EE3\u7801\u5931\u8D25:", error);
      new import_obsidian4.Notice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
    }
  }
  /**
   * 通用的剪贴板复制方法
   */
  async copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
    } catch (error) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "fixed";
      textArea.style.left = "-999999px";
      textArea.style.top = "-999999px";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      try {
        document.execCommand("copy");
      } finally {
        document.body.removeChild(textArea);
      }
    }
  }
  /**
   * 为页面上的所有术语元素添加LaTeX复制功能
   */
  enhanceTermElements(container = document.body) {
    const termElements = container.querySelectorAll("[data-term-id]");
    termElements.forEach((element) => {
      const termId = element.getAttribute("data-term-id");
      if (termId && element instanceof HTMLElement) {
        console.log("\u589E\u5F3A\u672F\u8BED\u5143\u7D20:", termId);
      }
    });
  }
};

// src/input/SmartMathInput.ts
var import_obsidian7 = require("obsidian");

// src/input/ContextAnalyzer.ts
var import_obsidian5 = require("obsidian");
var ContextAnalyzer = class {
  // 5分钟缓存过期
  constructor(app, termRecognitionEngine) {
    this.contextCache = /* @__PURE__ */ new Map();
    this.CACHE_EXPIRY = 5 * 60 * 1e3;
    this.app = app;
    this.termRecognitionEngine = termRecognitionEngine;
  }
  /**
   * 分析当前输入上下文
   */
  async analyzeContext(editor, file, cursor) {
    const cacheKey = `${file.path}-${cursor.line}-${cursor.ch}`;
    const cached = this.contextCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.CACHE_EXPIRY) {
      return cached.context;
    }
    const context = await this.performContextAnalysis(editor, file, cursor);
    this.contextCache.set(cacheKey, {
      context,
      timestamp: Date.now()
    });
    return context;
  }
  /**
   * 查找相关术语
   */
  async findRelatedTerms(query, context) {
    const relatedTerms = [];
    try {
      const noteTerms = await this.extractTermsFromNote(context.currentNote);
      relatedTerms.push(...noteTerms.filter(
        (term) => this.isTermRelevant(term, query, context)
      ));
      const surroundingTerms = await this.extractTermsFromText(context.surroundingText);
      relatedTerms.push(...surroundingTerms.filter(
        (term) => this.isTermRelevant(term, query, context)
      ));
      const recentTerms = await this.getRecentTermsInCategory(context.detectedCategory);
      relatedTerms.push(...recentTerms.filter(
        (term) => this.isTermRelevant(term, query, context)
      ));
      return this.deduplicateAndRankTerms(relatedTerms, query, context);
    } catch (error) {
      console.error("ContextAnalyzer: \u67E5\u627E\u76F8\u5173\u672F\u8BED\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 预测用户意图
   */
  async predictUserIntent(editor, file, cursor) {
    const context = await this.analyzeContext(editor, file, cursor);
    const inputPattern = this.analyzeInputPattern(editor, cursor);
    const documentStructure = await this.analyzeDocumentStructure(file);
    return this.inferUserIntent(context, inputPattern, documentStructure);
  }
  /**
   * 获取上下文建议权重
   */
  getContextualWeights(context) {
    return {
      categoryRelevance: this.calculateCategoryRelevance(context),
      recentUsageWeight: this.calculateRecentUsageWeight(context),
      documentContextWeight: this.calculateDocumentContextWeight(context),
      semanticSimilarityWeight: this.calculateSemanticSimilarityWeight(context)
    };
  }
  /**
   * 执行上下文分析
   */
  async performContextAnalysis(editor, file, cursor) {
    const currentLine = editor.getLine(cursor.line);
    const surroundingText = this.extractSurroundingText(editor, cursor);
    const detectedCategory = await this.detectMathCategory(surroundingText, file);
    const recentTerms = await this.extractRecentTerms(editor, cursor);
    return {
      currentNote: file.path,
      surroundingText,
      detectedCategory,
      recentTerms,
      cursorPosition: cursor.ch
    };
  }
  /**
   * 提取周围文本
   */
  extractSurroundingText(editor, cursor, radius = 3) {
    const startLine = Math.max(0, cursor.line - radius);
    const endLine = Math.min(editor.lineCount() - 1, cursor.line + radius);
    let surroundingText = "";
    for (let i = startLine; i <= endLine; i++) {
      surroundingText += editor.getLine(i) + "\n";
    }
    return surroundingText.trim();
  }
  /**
   * 检测数学领域类别
   */
  async detectMathCategory(text, file) {
    const categoryKeywords = {
      ["\u5FAE\u79EF\u5206" /* CALCULUS */]: [
        "\u5BFC\u6570",
        "\u79EF\u5206",
        "\u6781\u9650",
        "\u5FAE\u5206",
        "\u504F\u5BFC",
        "\u68AF\u5EA6",
        "\u6563\u5EA6",
        "\u65CB\u5EA6",
        "derivative",
        "integral",
        "limit",
        "differential"
      ],
      ["\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */]: [
        "\u77E9\u9635",
        "\u5411\u91CF",
        "\u884C\u5217\u5F0F",
        "\u7279\u5F81\u503C",
        "\u7279\u5F81\u5411\u91CF",
        "\u7EBF\u6027\u53D8\u6362",
        "\u57FA",
        "matrix",
        "vector",
        "determinant",
        "eigenvalue",
        "eigenvector"
      ],
      ["\u7EDF\u8BA1" /* STATISTICS */]: [
        "\u6982\u7387",
        "\u7EDF\u8BA1",
        "\u671F\u671B",
        "\u65B9\u5DEE",
        "\u6807\u51C6\u5DEE",
        "\u5206\u5E03",
        "\u5047\u8BBE\u68C0\u9A8C",
        "probability",
        "statistics",
        "expectation",
        "variance",
        "distribution"
      ],
      ["\u4EE3\u6570" /* ALGEBRA */]: [
        "\u591A\u9879\u5F0F",
        "\u65B9\u7A0B",
        "\u4E0D\u7B49\u5F0F",
        "\u51FD\u6570",
        "\u96C6\u5408",
        "\u7FA4",
        "\u73AF",
        "\u57DF",
        "polynomial",
        "equation",
        "inequality",
        "function",
        "set"
      ],
      ["\u51E0\u4F55" /* GEOMETRY */]: [
        "\u51E0\u4F55",
        "\u70B9",
        "\u7EBF",
        "\u9762",
        "\u89D2",
        "\u4E09\u89D2\u5F62",
        "\u5706",
        "\u692D\u5706",
        "\u629B\u7269\u7EBF",
        "geometry",
        "point",
        "line",
        "plane",
        "angle",
        "triangle",
        "circle"
      ],
      ["\u79BB\u6563\u6570\u5B66" /* DISCRETE_MATH */]: [
        "\u56FE\u8BBA",
        "\u7EC4\u5408",
        "\u9012\u63A8",
        "\u751F\u6210\u51FD\u6570",
        "\u79BB\u6563",
        "\u7B97\u6CD5",
        "graph",
        "combinatorics",
        "recursion",
        "discrete",
        "algorithm"
      ],
      ["\u6570\u8BBA" /* NUMBER_THEORY */]: [
        "\u6570\u8BBA",
        "\u8D28\u6570",
        "\u56E0\u6570",
        "\u540C\u4F59",
        "\u6B27\u62C9\u51FD\u6570",
        "\u8D39\u9A6C\u5B9A\u7406",
        "number theory",
        "prime",
        "factor",
        "congruence",
        "euler"
      ],
      ["\u62D3\u6251\u5B66" /* TOPOLOGY */]: [
        "\u62D3\u6251",
        "\u8FDE\u7EED",
        "\u7D27\u81F4",
        "\u8FDE\u901A",
        "\u540C\u80DA",
        "topology",
        "continuous",
        "compact",
        "connected",
        "homeomorphism"
      ],
      ["\u6570\u5B66\u5206\u6790" /* ANALYSIS */]: [
        "\u5206\u6790",
        "\u5B9E\u5206\u6790",
        "\u590D\u5206\u6790",
        "\u6CDB\u51FD",
        "\u6D4B\u5EA6",
        "analysis",
        "real analysis",
        "complex analysis",
        "functional",
        "measure"
      ],
      ["\u6982\u7387\u8BBA" /* PROBABILITY */]: [
        "\u6982\u7387\u8BBA",
        "\u968F\u673A",
        "\u671F\u671B",
        "\u65B9\u5DEE",
        "\u5206\u5E03",
        "probability",
        "random",
        "expectation",
        "variance",
        "distribution"
      ],
      ["\u96C6\u5408\u8BBA" /* SET_THEORY */]: [
        "\u96C6\u5408\u8BBA",
        "\u96C6\u5408",
        "\u5B50\u96C6",
        "\u5E76\u96C6",
        "\u4EA4\u96C6",
        "\u8865\u96C6",
        "set theory",
        "set",
        "subset",
        "union",
        "intersection",
        "complement"
      ],
      ["\u903B\u8F91" /* LOGIC */]: [
        "\u903B\u8F91",
        "\u547D\u9898",
        "\u8C13\u8BCD",
        "\u91CF\u8BCD",
        "\u63A8\u7406",
        "\u8BC1\u660E",
        "logic",
        "proposition",
        "predicate",
        "quantifier",
        "inference",
        "proof"
      ]
    };
    const categoryScores = {};
    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      let score = 0;
      for (const keyword of keywords) {
        const regex = new RegExp(keyword, "gi");
        const matches = text.match(regex);
        if (matches) {
          score += matches.length;
        }
      }
      categoryScores[category] = score;
    }
    const fileName = file.name.toLowerCase();
    const filePath = file.path.toLowerCase();
    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      for (const keyword of keywords) {
        if (fileName.includes(keyword) || filePath.includes(keyword)) {
          categoryScores[category] += 2;
        }
      }
    }
    let maxScore = 0;
    let detectedCategory = "\u4EE3\u6570" /* ALGEBRA */;
    for (const [category, score] of Object.entries(categoryScores)) {
      if (score > maxScore) {
        maxScore = score;
        detectedCategory = category;
      }
    }
    return detectedCategory;
  }
  /**
   * 提取最近使用的术语
   */
  async extractRecentTerms(editor, cursor, lookback = 50) {
    const recentTerms = [];
    try {
      let textBeforeCursor = "";
      for (let i = Math.max(0, cursor.line - 10); i <= cursor.line; i++) {
        const line = editor.getLine(i);
        if (i === cursor.line) {
          textBeforeCursor += line.substring(0, cursor.ch);
        } else {
          textBeforeCursor += line + "\n";
        }
      }
      const recognizedTerms = await this.termRecognitionEngine.recognizeTerms(textBeforeCursor);
      const sortedTerms = recognizedTerms.sort((a, b) => b.startIndex - a.startIndex).slice(0, lookback);
      for (const term of sortedTerms) {
        if (!recentTerms.includes(term.text)) {
          recentTerms.push(term.text);
        }
      }
    } catch (error) {
      console.warn("ContextAnalyzer: \u63D0\u53D6\u6700\u8FD1\u672F\u8BED\u5931\u8D25:", error);
    }
    return recentTerms;
  }
  /**
   * 从笔记中提取术语
   */
  async extractTermsFromNote(notePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(notePath);
      if (!file || !(file instanceof import_obsidian5.TFile)) {
        return [];
      }
      const content = await this.app.vault.read(file);
      const recognizedTerms = await this.termRecognitionEngine.recognizeTerms(content);
      return recognizedTerms.map((term) => ({
        id: `temp-${Date.now()}-${Math.random()}`,
        chineseName: term.text,
        category: term.category,
        latexCode: term.suggestedLatex,
        aliases: [],
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }));
    } catch (error) {
      console.warn("ContextAnalyzer: \u4ECE\u7B14\u8BB0\u63D0\u53D6\u672F\u8BED\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 从文本中提取术语
   */
  async extractTermsFromText(text) {
    try {
      const recognizedTerms = await this.termRecognitionEngine.recognizeTerms(text);
      return recognizedTerms.map((term) => ({
        id: `temp-${Date.now()}-${Math.random()}`,
        chineseName: term.text,
        category: term.category,
        latexCode: term.suggestedLatex,
        aliases: [],
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }));
    } catch (error) {
      console.warn("ContextAnalyzer: \u4ECE\u6587\u672C\u63D0\u53D6\u672F\u8BED\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 获取类别中的最近术语
   */
  async getRecentTermsInCategory(category) {
    try {
      return [];
    } catch (error) {
      console.warn("ContextAnalyzer: \u83B7\u53D6\u7C7B\u522B\u672F\u8BED\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 判断术语是否相关
   */
  isTermRelevant(term, query, context) {
    if (term.chineseName.includes(query) || query.includes(term.chineseName)) {
      return true;
    }
    if (term.category === context.detectedCategory) {
      return true;
    }
    if (term.aliases.some((alias) => alias.includes(query) || query.includes(alias))) {
      return true;
    }
    const similarity = this.calculateSemanticSimilarity(term.chineseName, query);
    return similarity > 0.6;
  }
  /**
   * 计算语义相似性（简化版）
   */
  calculateSemanticSimilarity(term1, term2) {
    const chars1 = new Set(term1);
    const chars2 = new Set(term2);
    const intersection = new Set([...chars1].filter((x) => chars2.has(x)));
    const union = /* @__PURE__ */ new Set([...chars1, ...chars2]);
    return intersection.size / union.size;
  }
  /**
   * 去重并排序术语
   */
  deduplicateAndRankTerms(terms, query, context) {
    const uniqueTerms = terms.filter(
      (term, index, self) => index === self.findIndex((t) => t.chineseName === term.chineseName)
    );
    return uniqueTerms.sort((a, b) => {
      const scoreA = this.calculateTermRelevanceScore(a, query, context);
      const scoreB = this.calculateTermRelevanceScore(b, query, context);
      return scoreB - scoreA;
    });
  }
  /**
   * 计算术语相关性分数
   */
  calculateTermRelevanceScore(term, query, context) {
    let score = 0;
    if (term.chineseName.includes(query)) {
      score += 3;
    }
    if (query.includes(term.chineseName)) {
      score += 2;
    }
    if (term.category === context.detectedCategory) {
      score += 2;
    }
    if (context.recentTerms.includes(term.chineseName)) {
      score += 1;
    }
    const similarity = this.calculateSemanticSimilarity(term.chineseName, query);
    score += similarity;
    return score;
  }
  /**
   * 分析输入模式
   */
  analyzeInputPattern(editor, cursor) {
    const currentLine = editor.getLine(cursor.line);
    const beforeCursor = currentLine.substring(0, cursor.ch);
    const afterCursor = currentLine.substring(cursor.ch);
    return {
      isInMathMode: this.isInMathMode(beforeCursor, afterCursor),
      isStartOfLine: cursor.ch === 0,
      isAfterSpace: beforeCursor.endsWith(" "),
      hasRecentMathContent: /[\u4e00-\u9fff]|\\[a-zA-Z]+/.test(beforeCursor.slice(-20)),
      inputSpeed: this.estimateInputSpeed(editor, cursor)
    };
  }
  /**
   * 检查是否在数学模式中
   */
  isInMathMode(beforeCursor, afterCursor) {
    const dollarsBefore = (beforeCursor.match(/\$/g) || []).length;
    const dollarsAfter = (afterCursor.match(/\$/g) || []).length;
    return dollarsBefore % 2 === 1;
  }
  /**
   * 估算输入速度
   */
  estimateInputSpeed(editor, cursor) {
    return "normal";
  }
  /**
   * 分析文档结构
   */
  async analyzeDocumentStructure(file) {
    var _a, _b;
    try {
      const content = await this.app.vault.read(file);
      const metadata = this.app.metadataCache.getFileCache(file);
      return {
        hasHeadings: (((_a = metadata == null ? void 0 : metadata.headings) == null ? void 0 : _a.length) || 0) > 0,
        hasMathBlocks: content.includes("$$"),
        hasInlineMath: content.includes("$") && !content.includes("$$"),
        hasLinks: (((_b = metadata == null ? void 0 : metadata.links) == null ? void 0 : _b.length) || 0) > 0,
        wordCount: content.split(/\s+/).length,
        mathContentRatio: this.calculateMathContentRatio(content)
      };
    } catch (error) {
      console.warn("ContextAnalyzer: \u6587\u6863\u7ED3\u6784\u5206\u6790\u5931\u8D25:", error);
      return {
        hasHeadings: false,
        hasMathBlocks: false,
        hasInlineMath: false,
        hasLinks: false,
        wordCount: 0,
        mathContentRatio: 0
      };
    }
  }
  /**
   * 计算数学内容比例
   */
  calculateMathContentRatio(content) {
    const mathPatterns = [
      /\$[^$]+\$/g,
      // 内联数学
      /\$\$[^$]+\$\$/g,
      // 块数学
      /\\[a-zA-Z]+/g,
      // LaTeX命令
      /[\u4e00-\u9fff]+/g
      // 中文数学术语
    ];
    let mathCharCount = 0;
    for (const pattern of mathPatterns) {
      const matches = content.match(pattern);
      if (matches) {
        mathCharCount += matches.join("").length;
      }
    }
    return content.length > 0 ? mathCharCount / content.length : 0;
  }
  /**
   * 推断用户意图
   */
  inferUserIntent(context, inputPattern, documentStructure) {
    if (inputPattern.isInMathMode) {
      return "formula_input";
    }
    if (documentStructure.mathContentRatio > 0.3) {
      return "math_note_writing";
    }
    if (context.recentTerms.length > 3) {
      return "concept_exploration";
    }
    return "general_writing";
  }
  /**
   * 计算类别相关性
   */
  calculateCategoryRelevance(context) {
    const categoryTermCount = context.recentTerms.length;
    return Math.min(1, categoryTermCount * 0.1);
  }
  /**
   * 计算最近使用权重
   */
  calculateRecentUsageWeight(context) {
    return Math.min(1, context.recentTerms.length * 0.05);
  }
  /**
   * 计算文档上下文权重
   */
  calculateDocumentContextWeight(context) {
    const mathContentRatio = this.calculateMathContentRatio(context.surroundingText);
    return mathContentRatio;
  }
  /**
   * 计算语义相似性权重
   */
  calculateSemanticSimilarityWeight(context) {
    return 0.5;
  }
  /**
   * 清理过期缓存
   */
  cleanupCache() {
    const now = Date.now();
    for (const [key, entry] of this.contextCache.entries()) {
      if (now - entry.timestamp > this.CACHE_EXPIRY) {
        this.contextCache.delete(key);
      }
    }
  }
};

// src/input/PersonalizedLearningEngine.ts
var import_obsidian6 = require("obsidian");
var PersonalizedLearningEngine = class {
  constructor(app) {
    this.usageHistory = [];
    this.isInitialized = false;
    this.app = app;
    this.userProfile = this.createDefaultProfile();
    this.learningModel = new LearningModel();
  }
  /**
   * 初始化学习引擎
   */
  async initialize() {
    if (this.isInitialized) return;
    try {
      await this.loadUserProfile();
      await this.loadUsageHistory();
      await this.learningModel.initialize(this.usageHistory);
      this.isInitialized = true;
      console.log("\u2705 PersonalizedLearningEngine: \u4E2A\u6027\u5316\u5B66\u4E60\u5F15\u64CE\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("PersonalizedLearningEngine: \u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 记录用户选择
   */
  async recordUserChoice(input, selected, context) {
    const record = {
      id: this.generateId(),
      timestamp: Date.now(),
      input,
      selected,
      context: context ? { ...context } : null,
      sessionId: this.getCurrentSessionId(),
      responseTime: 0,
      // 将在调用时设置
      userSatisfaction: null
      // 将通过其他方式收集
    };
    this.usageHistory.push(record);
    if (this.usageHistory.length > 1e4) {
      this.usageHistory = this.usageHistory.slice(-8e3);
    }
    this.saveUsageHistory().catch((error) => {
      console.warn("PersonalizedLearningEngine: \u4FDD\u5B58\u4F7F\u7528\u5386\u53F2\u5931\u8D25:", error);
    });
    await this.learningModel.updateFromRecord(record);
    console.log(`\u{1F4DA} PersonalizedLearningEngine: \u8BB0\u5F55\u7528\u6237\u9009\u62E9 "${input}" -> "${selected}"`);
  }
  /**
   * 更新个性化模型
   */
  async updatePersonalizationModel(input, selected) {
    try {
      this.updateUserPreferences(input, selected);
      this.updateCategoryPreferences(input, selected);
      this.updateInputPatterns(input, selected);
      await this.saveUserProfile();
    } catch (error) {
      console.error("PersonalizedLearningEngine: \u66F4\u65B0\u4E2A\u6027\u5316\u6A21\u578B\u5931\u8D25:", error);
    }
  }
  /**
   * 获取用户偏好
   */
  async getUserPreferences() {
    return {
      preferredCategories: this.userProfile.preferredCategories,
      preferredInputTypes: this.userProfile.preferredInputTypes,
      difficultyLevel: this.userProfile.difficultyLevel,
      learningStyle: this.userProfile.learningStyle,
      responseSpeedPreference: this.userProfile.responseSpeedPreference
    };
  }
  /**
   * 获取常用术语
   */
  async getFrequentlyUsedTerms(query) {
    const termFrequency = /* @__PURE__ */ new Map();
    for (const record of this.usageHistory) {
      if (record.selected.includes(query) || query.includes(record.selected)) {
        const count = termFrequency.get(record.selected) || 0;
        termFrequency.set(record.selected, count + 1);
      }
    }
    const frequentTerms = [];
    for (const [term, count] of termFrequency.entries()) {
      frequentTerms.push({ term, count });
    }
    return frequentTerms.sort((a, b) => b.count - a.count).slice(0, 10);
  }
  /**
   * 获取学习路径建议
   */
  async getLearningPathSuggestions(query, context) {
    const suggestions = [];
    try {
      const progressSuggestions = await this.generateProgressBasedSuggestions(query, context);
      suggestions.push(...progressSuggestions);
      const knowledgeGraphSuggestions = await this.generateKnowledgeGraphSuggestions(query, context);
      suggestions.push(...knowledgeGraphSuggestions);
      const difficultyBasedSuggestions = await this.generateDifficultyBasedSuggestions(query, context);
      suggestions.push(...difficultyBasedSuggestions);
    } catch (error) {
      console.warn("PersonalizedLearningEngine: \u751F\u6210\u5B66\u4E60\u8DEF\u5F84\u5EFA\u8BAE\u5931\u8D25:", error);
    }
    return suggestions;
  }
  /**
   * 预测用户需求
   */
  async predictUserNeeds(context) {
    const recentRecords = this.usageHistory.slice(-50);
    const patterns = this.analyzeUsagePatterns(recentRecords);
    const nextInputPrediction = await this.learningModel.predictNextInput(context, patterns);
    const difficultyPrediction = this.predictUserDifficulties(recentRecords);
    const learningGoals = this.predictLearningGoals(patterns);
    return {
      nextInputPrediction,
      difficultyPrediction,
      learningGoals,
      recommendedActions: this.generateRecommendedActions(patterns)
    };
  }
  /**
   * 获取个性化权重
   */
  getPersonalizationWeights(context) {
    return {
      categoryPreference: this.calculateCategoryPreferenceWeight(context),
      usageFrequency: this.calculateUsageFrequencyWeight(context),
      recentActivity: this.calculateRecentActivityWeight(),
      learningProgress: this.calculateLearningProgressWeight(context),
      difficultyAlignment: this.calculateDifficultyAlignmentWeight(context)
    };
  }
  /**
   * 创建默认用户档案
   */
  createDefaultProfile() {
    return {
      userId: this.generateUserId(),
      createdAt: Date.now(),
      lastUpdated: Date.now(),
      // 偏好设置
      preferredCategories: ["\u4EE3\u6570" /* ALGEBRA */],
      // 默认代数
      preferredInputTypes: ["term", "formula"],
      difficultyLevel: 0.5,
      // 中等难度
      learningStyle: "balanced",
      responseSpeedPreference: "normal",
      // 使用统计
      totalSessions: 0,
      totalInputs: 0,
      averageSessionDuration: 0,
      // 学习进度
      masteredConcepts: /* @__PURE__ */ new Set(),
      strugglingConcepts: /* @__PURE__ */ new Set(),
      learningGoals: [],
      // 行为模式
      inputPatterns: /* @__PURE__ */ new Map(),
      errorPatterns: /* @__PURE__ */ new Map(),
      successPatterns: /* @__PURE__ */ new Map(),
      // 个性化参数
      adaptationRate: 0.1,
      forgettingRate: 0.05,
      confidenceThreshold: 0.7
    };
  }
  /**
   * 加载用户档案
   */
  async loadUserProfile() {
    try {
      const profilePath = ".obsidian/plugins/math-memory-graph/user-profile.json";
      const file = this.app.vault.getAbstractFileByPath(profilePath);
      if (file && file instanceof import_obsidian6.TFile) {
        const content = await this.app.vault.read(file);
        const savedProfile = JSON.parse(content);
        this.userProfile = { ...this.userProfile, ...savedProfile };
        if (savedProfile.masteredConcepts) {
          this.userProfile.masteredConcepts = new Set(savedProfile.masteredConcepts);
        }
        if (savedProfile.strugglingConcepts) {
          this.userProfile.strugglingConcepts = new Set(savedProfile.strugglingConcepts);
        }
        if (savedProfile.inputPatterns) {
          this.userProfile.inputPatterns = new Map(Object.entries(savedProfile.inputPatterns));
        }
        if (savedProfile.errorPatterns) {
          this.userProfile.errorPatterns = new Map(Object.entries(savedProfile.errorPatterns));
        }
        if (savedProfile.successPatterns) {
          this.userProfile.successPatterns = new Map(Object.entries(savedProfile.successPatterns));
        }
        console.log("\u2705 PersonalizedLearningEngine: \u7528\u6237\u6863\u6848\u52A0\u8F7D\u5B8C\u6210");
      }
    } catch (error) {
      console.warn("PersonalizedLearningEngine: \u52A0\u8F7D\u7528\u6237\u6863\u6848\u5931\u8D25\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u6863\u6848:", error);
    }
  }
  /**
   * 保存用户档案
   */
  async saveUserProfile() {
    try {
      const profilePath = ".obsidian/plugins/math-memory-graph/user-profile.json";
      const serializableProfile = {
        ...this.userProfile,
        masteredConcepts: Array.from(this.userProfile.masteredConcepts),
        strugglingConcepts: Array.from(this.userProfile.strugglingConcepts),
        inputPatterns: Object.fromEntries(this.userProfile.inputPatterns),
        errorPatterns: Object.fromEntries(this.userProfile.errorPatterns),
        successPatterns: Object.fromEntries(this.userProfile.successPatterns),
        lastUpdated: Date.now()
      };
      const content = JSON.stringify(serializableProfile, null, 2);
      const dir = profilePath.substring(0, profilePath.lastIndexOf("/"));
      if (!await this.app.vault.adapter.exists(dir)) {
        await this.app.vault.adapter.mkdir(dir);
      }
      await this.app.vault.adapter.write(profilePath, content);
    } catch (error) {
      console.error("PersonalizedLearningEngine: \u4FDD\u5B58\u7528\u6237\u6863\u6848\u5931\u8D25:", error);
    }
  }
  /**
   * 加载使用历史
   */
  async loadUsageHistory() {
    try {
      const historyPath = ".obsidian/plugins/math-memory-graph/usage-history.json";
      const file = this.app.vault.getAbstractFileByPath(historyPath);
      if (file && file instanceof import_obsidian6.TFile) {
        const content = await this.app.vault.read(file);
        this.usageHistory = JSON.parse(content);
        console.log(`\u2705 PersonalizedLearningEngine: \u52A0\u8F7D\u4E86${this.usageHistory.length}\u6761\u4F7F\u7528\u5386\u53F2`);
      }
    } catch (error) {
      console.warn("PersonalizedLearningEngine: \u52A0\u8F7D\u4F7F\u7528\u5386\u53F2\u5931\u8D25:", error);
      this.usageHistory = [];
    }
  }
  /**
   * 保存使用历史
   */
  async saveUsageHistory() {
    try {
      const historyPath = ".obsidian/plugins/math-memory-graph/usage-history.json";
      const content = JSON.stringify(this.usageHistory, null, 2);
      const dir = historyPath.substring(0, historyPath.lastIndexOf("/"));
      if (!await this.app.vault.adapter.exists(dir)) {
        await this.app.vault.adapter.mkdir(dir);
      }
      await this.app.vault.adapter.write(historyPath, content);
    } catch (error) {
      console.error("PersonalizedLearningEngine: \u4FDD\u5B58\u4F7F\u7528\u5386\u53F2\u5931\u8D25:", error);
    }
  }
  /**
   * 更新用户偏好
   */
  updateUserPreferences(input, selected) {
    const pattern = this.extractInputPattern(input);
    const currentCount = this.userProfile.inputPatterns.get(pattern) || 0;
    this.userProfile.inputPatterns.set(pattern, currentCount + 1);
    const successKey = `${input}->${selected}`;
    const successCount = this.userProfile.successPatterns.get(successKey) || 0;
    this.userProfile.successPatterns.set(successKey, successCount + 1);
    this.userProfile.totalInputs++;
  }
  /**
   * 更新类别偏好
   */
  updateCategoryPreferences(input, selected) {
    const inferredCategory = this.inferCategoryFromSelection(selected);
    if (inferredCategory && !this.userProfile.preferredCategories.includes(inferredCategory)) {
      const categoryUsage = this.countCategoryUsage(inferredCategory);
      if (categoryUsage > 10) {
        this.userProfile.preferredCategories.push(inferredCategory);
      }
    }
  }
  /**
   * 更新输入模式
   */
  updateInputPatterns(input, selected) {
    const pattern = this.extractInputPattern(input);
    const currentCount = this.userProfile.inputPatterns.get(pattern) || 0;
    this.userProfile.inputPatterns.set(pattern, currentCount + 1);
  }
  /**
   * 生成基于进度的建议
   */
  async generateProgressBasedSuggestions(query, context) {
    const suggestions = [];
    for (const masteredConcept of this.userProfile.masteredConcepts) {
      if (masteredConcept.includes(query) || query.includes(masteredConcept)) {
        suggestions.push({
          text: masteredConcept,
          latexCode: `\\text{${masteredConcept}}`,
          description: "\u5DF2\u638C\u63E1\u7684\u76F8\u5173\u6982\u5FF5",
          score: 0.8,
          type: "term",
          category: (context == null ? void 0 : context.detectedCategory) || "\u4EE3\u6570" /* ALGEBRA */
        });
      }
    }
    return suggestions;
  }
  /**
   * 生成知识图谱建议
   */
  async generateKnowledgeGraphSuggestions(query, context) {
    return [];
  }
  /**
   * 生成基于难度的建议
   */
  async generateDifficultyBasedSuggestions(query, context) {
    const suggestions = [];
    const userDifficulty = this.userProfile.difficultyLevel;
    if (userDifficulty < 0.3) {
      suggestions.push({
        text: "\u57FA\u7840\u6982\u5FF5",
        latexCode: "\\text{\u57FA\u7840}",
        description: "\u9002\u5408\u521D\u5B66\u8005\u7684\u57FA\u7840\u6982\u5FF5",
        score: 0.7,
        type: "term",
        category: "\u4EE3\u6570" /* ALGEBRA */
      });
    } else if (userDifficulty > 0.7) {
      suggestions.push({
        text: "\u9AD8\u7EA7\u6982\u5FF5",
        latexCode: "\\text{\u9AD8\u7EA7}",
        description: "\u9002\u5408\u9AD8\u7EA7\u7528\u6237\u7684\u590D\u6742\u6982\u5FF5",
        score: 0.7,
        type: "term",
        category: (context == null ? void 0 : context.detectedCategory) || "\u4EE3\u6570" /* ALGEBRA */
      });
    }
    return suggestions;
  }
  /**
   * 分析使用模式
   */
  analyzeUsagePatterns(records) {
    const patterns = {
      mostUsedInputs: /* @__PURE__ */ new Map(),
      preferredTimeOfDay: this.calculatePreferredTimeOfDay(records),
      averageSessionLength: this.calculateAverageSessionLength(records),
      errorRate: this.calculateErrorRate(records),
      improvementTrend: this.calculateImprovementTrend(records)
    };
    for (const record of records) {
      const count = patterns.mostUsedInputs.get(record.input) || 0;
      patterns.mostUsedInputs.set(record.input, count + 1);
    }
    return patterns;
  }
  /**
   * 预测用户困难点
   */
  predictUserDifficulties(records) {
    const difficulties = [];
    for (const [pattern, count] of this.userProfile.errorPatterns.entries()) {
      if (count > 3) {
        difficulties.push(pattern);
      }
    }
    return difficulties;
  }
  /**
   * 预测学习目标
   */
  predictLearningGoals(patterns) {
    const goals = [];
    const mostUsed = Array.from(patterns.mostUsedInputs.entries()).sort((a, b) => b[1] - a[1]).slice(0, 3);
    for (const [input, count] of mostUsed) {
      if (count > 5) {
        goals.push(`\u638C\u63E1 ${input} \u76F8\u5173\u6982\u5FF5`);
      }
    }
    return goals;
  }
  /**
   * 生成推荐行动
   */
  generateRecommendedActions(patterns) {
    const actions = [];
    if (patterns.errorRate > 0.3) {
      actions.push("\u5EFA\u8BAE\u590D\u4E60\u57FA\u7840\u6982\u5FF5");
    }
    if (patterns.averageSessionLength < 5) {
      actions.push("\u5EFA\u8BAE\u5EF6\u957F\u5B66\u4E60\u65F6\u95F4");
    }
    if (patterns.improvementTrend < 0) {
      actions.push("\u5EFA\u8BAE\u8C03\u6574\u5B66\u4E60\u7B56\u7565");
    }
    return actions;
  }
  /**
   * 计算各种权重
   */
  calculateCategoryPreferenceWeight(context) {
    if (!context) return 0.5;
    const categoryCount = this.countCategoryUsage(context.detectedCategory);
    return Math.min(1, categoryCount * 0.01);
  }
  calculateUsageFrequencyWeight(context) {
    return Math.min(1, this.userProfile.totalInputs * 1e-3);
  }
  calculateRecentActivityWeight() {
    const recentRecords = this.usageHistory.filter(
      (record) => Date.now() - record.timestamp < 24 * 60 * 60 * 1e3
      // 24小时内
    );
    return Math.min(1, recentRecords.length * 0.1);
  }
  calculateLearningProgressWeight(context) {
    const masteredCount = this.userProfile.masteredConcepts.size;
    return Math.min(1, masteredCount * 0.05);
  }
  calculateDifficultyAlignmentWeight(context) {
    return this.userProfile.difficultyLevel;
  }
  /**
   * 辅助方法
   */
  generateId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  generateUserId() {
    return `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  getCurrentSessionId() {
    return `session-${Date.now()}`;
  }
  extractInputPattern(input) {
    if (/^[\u4e00-\u9fff]+$/.test(input)) return "chinese-only";
    if (/^[a-zA-Z]+$/.test(input)) return "english-only";
    if (/\\[a-zA-Z]+/.test(input)) return "latex-command";
    return "mixed";
  }
  inferCategoryFromSelection(selected) {
    if (selected.includes("frac") || selected.includes("\u5BFC\u6570") || selected.includes("\u79EF\u5206")) {
      return "\u5FAE\u79EF\u5206" /* CALCULUS */;
    }
    if (selected.includes("matrix") || selected.includes("vec") || selected.includes("\u77E9\u9635")) {
      return "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */;
    }
    return null;
  }
  countCategoryUsage(category) {
    return this.usageHistory.filter(
      (record) => {
        var _a;
        return ((_a = record.context) == null ? void 0 : _a.detectedCategory) === category;
      }
    ).length;
  }
  calculatePreferredTimeOfDay(records) {
    const hours = records.map((record) => new Date(record.timestamp).getHours());
    const hourCounts = new Array(24).fill(0);
    for (const hour of hours) {
      hourCounts[hour]++;
    }
    let maxCount = 0;
    let preferredHour = 12;
    for (let i = 0; i < 24; i++) {
      if (hourCounts[i] > maxCount) {
        maxCount = hourCounts[i];
        preferredHour = i;
      }
    }
    return preferredHour;
  }
  calculateAverageSessionLength(records) {
    return records.length > 0 ? records.length / 10 : 0;
  }
  calculateErrorRate(records) {
    return 0.1;
  }
  calculateImprovementTrend(records) {
    return 0.05;
  }
};
var LearningModel = class {
  constructor() {
    this.patterns = /* @__PURE__ */ new Map();
    this.predictions = /* @__PURE__ */ new Map();
  }
  async initialize(history) {
    for (const record of history) {
      this.updatePatterns(record);
    }
  }
  async updateFromRecord(record) {
    this.updatePatterns(record);
  }
  async predictNextInput(context, patterns) {
    const predictions = [];
    const mostUsed = Array.from(patterns.mostUsedInputs.entries()).sort((a, b) => b[1] - a[1]).slice(0, 3);
    for (const [input, count] of mostUsed) {
      predictions.push(input);
    }
    return predictions;
  }
  updatePatterns(record) {
    const key = `${record.input}->${record.selected}`;
    const count = this.patterns.get(key) || 0;
    this.patterns.set(key, count + 1);
  }
};

// src/input/SuggestionRanker.ts
var SuggestionRanker = class {
  constructor(learningEngine) {
    this.userFeedbackHistory = /* @__PURE__ */ new Map();
    this.learningEngine = learningEngine;
    this.rankingWeights = this.getDefaultWeights();
  }
  /**
   * 对建议进行智能排序
   */
  async rankSuggestions(suggestions, query, context) {
    if (suggestions.length === 0) return suggestions;
    try {
      const scoredSuggestions = await Promise.all(
        suggestions.map(async (suggestion) => {
          const score = await this.calculateComprehensiveScore(suggestion, query, context);
          return { ...suggestion, score };
        })
      );
      const rankedSuggestions = scoredSuggestions.sort((a, b) => b.score - a.score);
      const diversifiedSuggestions = this.applyDiversityAdjustment(rankedSuggestions);
      const personalizedSuggestions = await this.applyPersonalizationAdjustment(
        diversifiedSuggestions,
        query,
        context
      );
      console.log(`\u{1F3AF} SuggestionRanker: \u5BF9${suggestions.length}\u4E2A\u5EFA\u8BAE\u8FDB\u884C\u4E86\u667A\u80FD\u6392\u5E8F`);
      return personalizedSuggestions;
    } catch (error) {
      console.error("SuggestionRanker: \u5EFA\u8BAE\u6392\u5E8F\u5931\u8D25:", error);
      return suggestions;
    }
  }
  /**
   * 从用户反馈中学习
   */
  updateFromUserFeedback(query, selectedSuggestion) {
    const feedbackKey = this.generateFeedbackKey(query);
    if (!this.userFeedbackHistory.has(feedbackKey)) {
      this.userFeedbackHistory.set(feedbackKey, []);
    }
    const feedbackRecord = {
      timestamp: Date.now(),
      query,
      selectedSuggestion,
      queryLength: query.length,
      selectionRank: -1
      // 将在后续计算中设置
    };
    this.userFeedbackHistory.get(feedbackKey).push(feedbackRecord);
    const history = this.userFeedbackHistory.get(feedbackKey);
    if (history.length > 100) {
      this.userFeedbackHistory.set(feedbackKey, history.slice(-80));
    }
    this.adjustWeightsFromFeedback(feedbackRecord);
  }
  /**
   * 获取排序性能指标
   */
  getRankingMetrics() {
    let totalFeedback = 0;
    let averageSelectionRank = 0;
    let topThreeSelectionRate = 0;
    for (const history of this.userFeedbackHistory.values()) {
      totalFeedback += history.length;
      for (const record of history) {
        if (record.selectionRank >= 0) {
          averageSelectionRank += record.selectionRank;
          if (record.selectionRank < 3) {
            topThreeSelectionRate++;
          }
        }
      }
    }
    return {
      totalFeedbackCount: totalFeedback,
      averageSelectionRank: totalFeedback > 0 ? averageSelectionRank / totalFeedback : 0,
      topThreeSelectionRate: totalFeedback > 0 ? topThreeSelectionRate / totalFeedback : 0,
      rankingAccuracy: this.calculateRankingAccuracy()
    };
  }
  /**
   * 计算综合分数
   */
  async calculateComprehensiveScore(suggestion, query, context) {
    let score = 0;
    const relevanceScore = this.calculateRelevanceScore(suggestion, query);
    score += relevanceScore * this.rankingWeights.relevance;
    const contextScore = this.calculateContextScore(suggestion, context);
    score += contextScore * this.rankingWeights.context;
    const preferenceScore = await this.calculatePreferenceScore(suggestion, context);
    score += preferenceScore * this.rankingWeights.preference;
    const qualityScore = this.calculateQualityScore(suggestion);
    score += qualityScore * this.rankingWeights.quality;
    const noveltyScore = this.calculateNoveltyScore(suggestion, query);
    score += noveltyScore * this.rankingWeights.novelty;
    return Math.max(0, Math.min(1, score));
  }
  /**
   * 计算相关性分数
   */
  calculateRelevanceScore(suggestion, query) {
    let score = 0;
    const textMatch = this.calculateTextSimilarity(suggestion.text, query);
    score += textMatch * 0.4;
    const latexMatch = this.calculateLatexRelevance(suggestion.latexCode, query);
    score += latexMatch * 0.3;
    const descriptionMatch = this.calculateTextSimilarity(suggestion.description, query);
    score += descriptionMatch * 0.2;
    score += suggestion.score * 0.1;
    return score;
  }
  /**
   * 计算上下文分数
   */
  calculateContextScore(suggestion, context) {
    if (!context) return 0.5;
    let score = 0;
    if (suggestion.category === context.detectedCategory) {
      score += 0.4;
    }
    const recentTermRelevance = this.calculateRecentTermRelevance(suggestion, context.recentTerms);
    score += recentTermRelevance * 0.3;
    const surroundingTextRelevance = this.calculateSurroundingTextRelevance(
      suggestion,
      context.surroundingText
    );
    score += surroundingTextRelevance * 0.3;
    return score;
  }
  /**
   * 计算用户偏好分数
   */
  async calculatePreferenceScore(suggestion, context) {
    try {
      const preferences = await this.learningEngine.getUserPreferences();
      let score = 0;
      if (preferences.preferredCategories.includes(suggestion.category)) {
        score += 0.4;
      }
      if (preferences.preferredInputTypes.includes(suggestion.type)) {
        score += 0.3;
      }
      const difficultyMatch = this.calculateDifficultyMatch(suggestion, preferences.difficultyLevel);
      score += difficultyMatch * 0.3;
      return score;
    } catch (error) {
      console.warn("SuggestionRanker: \u8BA1\u7B97\u7528\u6237\u504F\u597D\u5206\u6570\u5931\u8D25:", error);
      return 0.5;
    }
  }
  /**
   * 计算质量分数
   */
  calculateQualityScore(suggestion) {
    let score = 0;
    const latexQuality = this.assessLatexQuality(suggestion.latexCode);
    score += latexQuality * 0.4;
    const descriptionQuality = this.assessDescriptionQuality(suggestion.description);
    score += descriptionQuality * 0.3;
    const typeAppropriatenesss = this.assessTypeAppropriateness(suggestion);
    score += typeAppropriatenesss * 0.3;
    return score;
  }
  /**
   * 计算新颖性分数
   */
  calculateNoveltyScore(suggestion, query) {
    const feedbackKey = this.generateFeedbackKey(query);
    const history = this.userFeedbackHistory.get(feedbackKey) || [];
    const hasBeenSelected = history.some(
      (record) => record.selectedSuggestion === suggestion.text || record.selectedSuggestion === suggestion.latexCode
    );
    if (!hasBeenSelected) {
      return 0.8;
    }
    const selectionCount = history.filter(
      (record) => record.selectedSuggestion === suggestion.text || record.selectedSuggestion === suggestion.latexCode
    ).length;
    return Math.max(0.1, 1 - selectionCount * 0.1);
  }
  /**
   * 应用多样性调整
   */
  applyDiversityAdjustment(suggestions) {
    if (suggestions.length <= 3) return suggestions;
    const diversifiedSuggestions = [];
    const usedCategories = /* @__PURE__ */ new Set();
    const usedTypes = /* @__PURE__ */ new Set();
    if (suggestions.length > 0) {
      diversifiedSuggestions.push(suggestions[0]);
      usedCategories.add(suggestions[0].category);
      usedTypes.add(suggestions[0].type);
    }
    for (let i = 1; i < suggestions.length; i++) {
      const suggestion = suggestions[i];
      let diversityBonus = 0;
      if (!usedCategories.has(suggestion.category)) {
        diversityBonus += 0.1;
      }
      if (!usedTypes.has(suggestion.type)) {
        diversityBonus += 0.05;
      }
      const adjustedSuggestion = {
        ...suggestion,
        score: Math.min(1, suggestion.score + diversityBonus)
      };
      diversifiedSuggestions.push(adjustedSuggestion);
      usedCategories.add(suggestion.category);
      usedTypes.add(suggestion.type);
    }
    return diversifiedSuggestions.sort((a, b) => b.score - a.score);
  }
  /**
   * 应用个性化调整
   */
  async applyPersonalizationAdjustment(suggestions, query, context) {
    try {
      const personalizationWeights = this.learningEngine.getPersonalizationWeights(context);
      return suggestions.map((suggestion) => {
        let personalizedScore = suggestion.score;
        if (context && suggestion.category === context.detectedCategory) {
          personalizedScore += personalizationWeights.categoryPreference * 0.1;
        }
        personalizedScore += personalizationWeights.usageFrequency * 0.05;
        personalizedScore += personalizationWeights.recentActivity * 0.05;
        personalizedScore += personalizationWeights.learningProgress * 0.05;
        return {
          ...suggestion,
          score: Math.max(0, Math.min(1, personalizedScore))
        };
      }).sort((a, b) => b.score - a.score);
    } catch (error) {
      console.warn("SuggestionRanker: \u4E2A\u6027\u5316\u8C03\u6574\u5931\u8D25:", error);
      return suggestions;
    }
  }
  /**
   * 辅助计算方法
   */
  calculateTextSimilarity(text1, text2) {
    if (!text1 || !text2) return 0;
    const lowerText1 = text1.toLowerCase();
    const lowerText2 = text2.toLowerCase();
    if (lowerText1 === lowerText2) return 1;
    if (lowerText1.includes(lowerText2) || lowerText2.includes(lowerText1)) {
      return 0.8;
    }
    const chars1 = new Set(lowerText1);
    const chars2 = new Set(lowerText2);
    const intersection = new Set([...chars1].filter((x) => chars2.has(x)));
    const union = /* @__PURE__ */ new Set([...chars1, ...chars2]);
    return intersection.size / union.size;
  }
  calculateLatexRelevance(latexCode, query) {
    if (!latexCode || !query) return 0;
    const latexCommands = latexCode.match(/\\[a-zA-Z]+/g) || [];
    const queryLower = query.toLowerCase();
    for (const command of latexCommands) {
      const commandName = command.substring(1);
      if (queryLower.includes(commandName) || commandName.includes(queryLower)) {
        return 0.8;
      }
    }
    const mathSymbols = ["frac", "sqrt", "sum", "int", "lim", "alpha", "beta", "gamma"];
    for (const symbol of mathSymbols) {
      if (latexCode.includes(symbol) && queryLower.includes(symbol)) {
        return 0.6;
      }
    }
    return 0.2;
  }
  calculateRecentTermRelevance(suggestion, recentTerms) {
    if (recentTerms.length === 0) return 0;
    for (const term of recentTerms) {
      if (suggestion.text.includes(term) || term.includes(suggestion.text)) {
        return 0.8;
      }
    }
    return 0.2;
  }
  calculateSurroundingTextRelevance(suggestion, surroundingText) {
    if (!surroundingText) return 0;
    const relevanceScore = this.calculateTextSimilarity(suggestion.text, surroundingText);
    return relevanceScore * 0.5;
  }
  calculateDifficultyMatch(suggestion, userDifficultyLevel) {
    let suggestionDifficulty = 0.5;
    const latexComplexity = this.assessLatexComplexity(suggestion.latexCode);
    suggestionDifficulty = latexComplexity;
    const difficultyDifference = Math.abs(suggestionDifficulty - userDifficultyLevel);
    return 1 - difficultyDifference;
  }
  assessLatexQuality(latexCode) {
    if (!latexCode) return 0;
    let quality = 0.5;
    const openBraces = (latexCode.match(/\{/g) || []).length;
    const closeBraces = (latexCode.match(/\}/g) || []).length;
    if (openBraces === closeBraces) {
      quality += 0.2;
    }
    if (latexCode.includes("\\")) {
      quality += 0.2;
    }
    if (latexCode.length > 100) {
      quality -= 0.1;
    }
    return Math.max(0, Math.min(1, quality));
  }
  assessDescriptionQuality(description) {
    if (!description) return 0.3;
    let quality = 0.5;
    if (description.length >= 10 && description.length <= 100) {
      quality += 0.2;
    }
    if (description.includes("\u672F\u8BED") || description.includes("\u516C\u5F0F") || description.includes("\u6A21\u677F")) {
      quality += 0.2;
    }
    if (!description.includes("undefined") && !description.includes("null")) {
      quality += 0.1;
    }
    return Math.max(0, Math.min(1, quality));
  }
  assessTypeAppropriateness(suggestion) {
    if (suggestion.type === "term" && suggestion.latexCode.includes("\\text")) {
      return 0.8;
    }
    if (suggestion.type === "formula" && suggestion.latexCode.includes("=")) {
      return 0.8;
    }
    if (suggestion.type === "template" && suggestion.latexCode.includes("${")) {
      return 0.8;
    }
    return 0.6;
  }
  assessLatexComplexity(latexCode) {
    if (!latexCode) return 0;
    let complexity = 0;
    const commands = (latexCode.match(/\\[a-zA-Z]+/g) || []).length;
    complexity += Math.min(0.5, commands * 0.1);
    const braceDepth = this.calculateMaxBraceDepth(latexCode);
    complexity += Math.min(0.3, braceDepth * 0.1);
    complexity += Math.min(0.2, latexCode.length * 0.01);
    return Math.max(0, Math.min(1, complexity));
  }
  calculateMaxBraceDepth(text) {
    let maxDepth = 0;
    let currentDepth = 0;
    for (const char of text) {
      if (char === "{") {
        currentDepth++;
        maxDepth = Math.max(maxDepth, currentDepth);
      } else if (char === "}") {
        currentDepth--;
      }
    }
    return maxDepth;
  }
  generateFeedbackKey(query) {
    return query.toLowerCase().substring(0, 3);
  }
  adjustWeightsFromFeedback(feedback) {
    const adjustmentFactor = 0.01;
    if (feedback.selectedSuggestion.includes("\\")) {
      this.rankingWeights.quality += adjustmentFactor;
    }
    this.normalizeWeights();
  }
  normalizeWeights() {
    const total = Object.values(this.rankingWeights).reduce((sum, weight) => sum + weight, 0);
    if (total > 0) {
      for (const key in this.rankingWeights) {
        this.rankingWeights[key] /= total;
      }
    }
  }
  calculateRankingAccuracy() {
    let totalAccuracy = 0;
    let totalRecords = 0;
    for (const history of this.userFeedbackHistory.values()) {
      for (const record of history) {
        if (record.selectionRank >= 0) {
          const accuracy = Math.max(0, 1 - record.selectionRank * 0.2);
          totalAccuracy += accuracy;
          totalRecords++;
        }
      }
    }
    return totalRecords > 0 ? totalAccuracy / totalRecords : 0;
  }
  getDefaultWeights() {
    return {
      relevance: 0.3,
      context: 0.25,
      preference: 0.2,
      quality: 0.15,
      novelty: 0.1
    };
  }
};

// src/input/SmartMathInput.ts
var SmartMathInput = class extends import_obsidian7.EditorSuggest {
  constructor(app, neuralConverter, termRecognitionEngine) {
    super(app);
    this.isActive = false;
    this.currentContext = null;
    this.suggestionCache = /* @__PURE__ */ new Map();
    this.performanceMetrics = {
      totalSuggestions: 0,
      averageResponseTime: 0,
      cacheHitRate: 0,
      userAcceptanceRate: 0
    };
    this.app = app;
    this.neuralConverter = neuralConverter;
    this.termRecognitionEngine = termRecognitionEngine;
    this.contextAnalyzer = new ContextAnalyzer(app, termRecognitionEngine);
    this.learningEngine = new PersonalizedLearningEngine(app);
    this.suggestionRanker = new SuggestionRanker(this.learningEngine);
    this.limit = 10;
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: "\u5BFC\u822A\u5EFA\u8BAE"
      },
      {
        command: "\u21B5",
        purpose: "\u9009\u62E9\u5EFA\u8BAE"
      },
      {
        command: "Esc",
        purpose: "\u5173\u95ED\u5EFA\u8BAE"
      }
    ]);
  }
  /**
   * 激活智能输入模式
   */
  activate(editor) {
    var _a;
    if (this.isActive) return;
    this.isActive = true;
    console.log("\u{1F680} SmartMathInput: AI\u667A\u80FD\u8F93\u5165\u6A21\u5F0F\u5DF2\u6FC0\u6D3B");
    try {
      (_a = this.app.workspace.editorSuggest) == null ? void 0 : _a.addChild(this);
    } catch (error) {
      console.warn("SmartMathInput: \u65E0\u6CD5\u6CE8\u518C\u5EFA\u8BAE\u5668:", error);
    }
    this.learningEngine.initialize();
    this.showActivationNotice();
  }
  /**
   * 停用智能输入模式
   */
  deactivate() {
    var _a;
    if (!this.isActive) return;
    this.isActive = false;
    console.log("\u23F9\uFE0F SmartMathInput: AI\u667A\u80FD\u8F93\u5165\u6A21\u5F0F\u5DF2\u505C\u7528");
    try {
      (_a = this.app.workspace.editorSuggest) == null ? void 0 : _a.removeChild(this);
    } catch (error) {
      console.warn("SmartMathInput: \u65E0\u6CD5\u79FB\u9664\u5EFA\u8BAE\u5668:", error);
    }
    this.suggestionCache.clear();
    this.currentContext = null;
  }
  /**
   * 触发建议 - Obsidian EditorSuggest接口实现
   */
  onTrigger(cursor, editor, file) {
    if (!this.isActive) return null;
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    if (this.shouldTriggerSuggestion(beforeCursor)) {
      const triggerInfo = this.extractTriggerInfo(beforeCursor, cursor);
      if (triggerInfo) {
        this.updateContextAsync(editor, file, cursor);
        return triggerInfo;
      }
    }
    return null;
  }
  /**
   * 获取建议列表 - 支持两种接口
   */
  async getSuggestions(contextOrInput, inputContext) {
    const startTime = performance.now();
    try {
      let query;
      let context;
      if (typeof contextOrInput === "string") {
        query = contextOrInput.toLowerCase().trim();
        context = inputContext || null;
      } else {
        query = contextOrInput.query.toLowerCase().trim();
        context = this.currentContext;
      }
      if (!query) return [];
      const cacheKey = this.generateCacheKey(query, context);
      if (this.suggestionCache.has(cacheKey)) {
        this.performanceMetrics.cacheHitRate++;
        return this.suggestionCache.get(cacheKey);
      }
      const suggestions = await this.generateAISuggestions(query, context);
      this.suggestionCache.set(cacheKey, suggestions);
      const responseTime = performance.now() - startTime;
      this.updatePerformanceMetrics(responseTime);
      return suggestions;
    } catch (error) {
      console.error("SmartMathInput: \u83B7\u53D6\u5EFA\u8BAE\u5931\u8D25:", error);
      return [];
    }
  }
  /**
   * 渲染建议项 - Obsidian EditorSuggest接口实现
   */
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: "smart-math-suggestion" });
    const mainContent = container.createDiv({ cls: "suggestion-main" });
    const title = mainContent.createDiv({ cls: "suggestion-title" });
    title.textContent = suggestion.text;
    if (suggestion.latexCode) {
      const latexPreview = mainContent.createDiv({ cls: "suggestion-latex" });
      latexPreview.innerHTML = `<code>${suggestion.latexCode}</code>`;
    }
    if (suggestion.description) {
      const description = mainContent.createDiv({ cls: "suggestion-description" });
      description.textContent = suggestion.description;
    }
    const metadata = container.createDiv({ cls: "suggestion-metadata" });
    const typeTag = metadata.createSpan({ cls: `suggestion-type type-${suggestion.type}` });
    typeTag.textContent = this.getTypeDisplayName(suggestion.type);
    const categoryTag = metadata.createSpan({ cls: "suggestion-category" });
    categoryTag.textContent = suggestion.category;
    const confidenceBar = metadata.createDiv({ cls: "suggestion-confidence" });
    const confidenceLevel = Math.round(suggestion.score * 100);
    confidenceBar.style.width = `${confidenceLevel}%`;
    confidenceBar.title = `\u7F6E\u4FE1\u5EA6: ${confidenceLevel}%`;
    if (suggestion.score > 0.8) {
      const aiTag = metadata.createSpan({ cls: "suggestion-ai-enhanced" });
      aiTag.textContent = "\u{1F9E0} AI";
      aiTag.title = "AI\u589E\u5F3A\u5EFA\u8BAE";
    }
  }
  /**
   * 选择建议 - Obsidian EditorSuggest接口实现
   */
  selectSuggestion(suggestion, evt) {
    const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
    if (!activeView) return;
    const editor = activeView.editor;
    this.insertSuggestion(suggestion, editor);
    this.learnFromUsage(suggestion.text, suggestion.latexCode);
    this.performanceMetrics.userAcceptanceRate++;
  }
  /**
   * 插入建议到编辑器
   */
  insertSuggestion(suggestion, editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const replaceRange = this.findReplaceRange(beforeCursor);
    const startPos = { line: cursor.line, ch: cursor.ch - replaceRange.length };
    let insertText = "";
    switch (suggestion.type) {
      case "term":
        insertText = this.formatTermInsertion(suggestion);
        break;
      case "formula":
        insertText = this.formatFormulaInsertion(suggestion);
        break;
      case "template":
        insertText = this.formatTemplateInsertion(suggestion);
        break;
    }
    editor.replaceRange(insertText, startPos, cursor);
    this.positionCursorAfterInsertion(editor, startPos, insertText, suggestion);
    console.log(`\u2705 SmartMathInput: \u63D2\u5165\u5EFA\u8BAE "${suggestion.text}" -> "${insertText}"`);
  }
  /**
   * 从使用中学习
   */
  async learnFromUsage(input, selected) {
    try {
      await this.learningEngine.recordUserChoice(input, selected, this.currentContext);
      await this.learningEngine.updatePersonalizationModel(input, selected);
      this.suggestionRanker.updateFromUserFeedback(input, selected);
      console.log(`\u{1F4DA} SmartMathInput: \u5B66\u4E60\u8BB0\u5F55 "${input}" -> "${selected}"`);
    } catch (error) {
      console.error("SmartMathInput: \u5B66\u4E60\u8BB0\u5F55\u5931\u8D25:", error);
    }
  }
  /**
   * 生成AI增强建议
   */
  async generateAISuggestions(query, context) {
    const suggestions = [];
    const neuralSuggestions = await this.generateNeuralSuggestions(query, context);
    suggestions.push(...neuralSuggestions);
    const contextSuggestions = await this.generateContextSuggestions(query, context);
    suggestions.push(...contextSuggestions);
    const personalizedSuggestions = await this.generatePersonalizedSuggestions(query, context);
    suggestions.push(...personalizedSuggestions);
    const templateSuggestions = await this.generateTemplateSuggestions(query, context);
    suggestions.push(...templateSuggestions);
    const uniqueSuggestions = this.deduplicateSuggestions(suggestions);
    const rankedSuggestions = await this.suggestionRanker.rankSuggestions(uniqueSuggestions, query, context);
    return rankedSuggestions.slice(0, this.limit);
  }
  /**
   * 生成神经网络增强建议
   */
  async generateNeuralSuggestions(query, context) {
    const suggestions = [];
    try {
      const conversionResult = await this.neuralConverter.convertTerm(query);
      if (conversionResult.confidence > 0.5) {
        suggestions.push({
          text: query,
          latexCode: conversionResult.latexCode,
          description: `\u795E\u7ECF\u7F51\u7EDC\u8F6C\u6362 (\u7F6E\u4FE1\u5EA6: ${Math.round(conversionResult.confidence * 100)}%)`,
          score: conversionResult.confidence,
          type: "term",
          category: this.inferCategory(query, context)
        });
      }
      for (const alternative of conversionResult.alternatives) {
        suggestions.push({
          text: query,
          latexCode: alternative,
          description: "\u66FF\u4EE3LaTeX\u8868\u793A",
          score: conversionResult.confidence * 0.8,
          type: "term",
          category: this.inferCategory(query, context)
        });
      }
    } catch (error) {
      console.warn("SmartMathInput: \u795E\u7ECF\u7F51\u7EDC\u5EFA\u8BAE\u751F\u6210\u5931\u8D25:", error);
    }
    return suggestions;
  }
  /**
   * 生成上下文感知建议
   */
  async generateContextSuggestions(query, context) {
    if (!context) return [];
    const suggestions = [];
    try {
      const relatedTerms = await this.contextAnalyzer.findRelatedTerms(query, context);
      for (const term of relatedTerms) {
        const conversionResult = await this.neuralConverter.convertTerm(term.chineseName);
        suggestions.push({
          text: term.chineseName,
          latexCode: conversionResult.latexCode,
          description: `\u4E0A\u4E0B\u6587\u76F8\u5173\u672F\u8BED (${term.category})`,
          score: 0.7 + (term.chineseName.includes(query) ? 0.2 : 0),
          type: "term",
          category: term.category
        });
      }
      const domainSuggestions = await this.generateDomainSpecificSuggestions(query, context.detectedCategory);
      suggestions.push(...domainSuggestions);
    } catch (error) {
      console.warn("SmartMathInput: \u4E0A\u4E0B\u6587\u5EFA\u8BAE\u751F\u6210\u5931\u8D25:", error);
    }
    return suggestions;
  }
  /**
   * 生成个性化建议
   */
  async generatePersonalizedSuggestions(query, context) {
    const suggestions = [];
    try {
      const frequentTerms = await this.learningEngine.getFrequentlyUsedTerms(query);
      for (const term of frequentTerms) {
        const conversionResult = await this.neuralConverter.convertTerm(term.term);
        suggestions.push({
          text: term.term,
          latexCode: conversionResult.latexCode,
          description: `\u5E38\u7528\u672F\u8BED (\u4F7F\u7528${term.count}\u6B21)`,
          score: 0.6 + Math.min(0.3, term.count * 0.01),
          type: "term",
          category: this.inferCategory(term.term, context)
        });
      }
      const learningPathSuggestions = await this.learningEngine.getLearningPathSuggestions(query, context);
      suggestions.push(...learningPathSuggestions);
    } catch (error) {
      console.warn("SmartMathInput: \u4E2A\u6027\u5316\u5EFA\u8BAE\u751F\u6210\u5931\u8D25:", error);
    }
    return suggestions;
  }
  /**
   * 生成模板建议
   */
  async generateTemplateSuggestions(query, context) {
    const suggestions = [];
    const templates = [
      {
        trigger: ["\u5206\u6570", "frac"],
        template: "\\frac{${1:\u5206\u5B50}}{${2:\u5206\u6BCD}}",
        description: "\u5206\u6570\u6A21\u677F",
        category: "\u4EE3\u6570" /* ALGEBRA */
      },
      {
        trigger: ["\u6839\u53F7", "sqrt"],
        template: "\\sqrt{${1:\u8868\u8FBE\u5F0F}}",
        description: "\u5E73\u65B9\u6839\u6A21\u677F",
        category: "\u4EE3\u6570" /* ALGEBRA */
      },
      {
        trigger: ["\u79EF\u5206", "int"],
        template: "\\int_{${1:\u4E0B\u9650}}^{${2:\u4E0A\u9650}} ${3:\u88AB\u79EF\u51FD\u6570} \\, d${4:\u53D8\u91CF}",
        description: "\u5B9A\u79EF\u5206\u6A21\u677F",
        category: "\u5FAE\u79EF\u5206" /* CALCULUS */
      },
      {
        trigger: ["\u6C42\u548C", "sum"],
        template: "\\sum_{${1:i=1}}^{${2:n}} ${3:\u8868\u8FBE\u5F0F}",
        description: "\u6C42\u548C\u6A21\u677F",
        category: "\u4EE3\u6570" /* ALGEBRA */
      },
      {
        trigger: ["\u6781\u9650", "lim"],
        template: "\\lim_{${1:x \\to a}} ${2:\u51FD\u6570}",
        description: "\u6781\u9650\u6A21\u677F",
        category: "\u5FAE\u79EF\u5206" /* CALCULUS */
      },
      {
        trigger: ["\u77E9\u9635", "matrix"],
        template: "\\begin{pmatrix}\n${1:a} & ${2:b} \\\\\n${3:c} & ${4:d}\n\\end{pmatrix}",
        description: "2\xD72\u77E9\u9635\u6A21\u677F",
        category: "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */
      }
    ];
    for (const template of templates) {
      if (template.trigger.some((trigger) => trigger.includes(query) || query.includes(trigger))) {
        suggestions.push({
          text: template.description,
          latexCode: template.template,
          description: `LaTeX\u6A21\u677F - ${template.description}`,
          score: 0.8,
          type: "template",
          category: template.category
        });
      }
    }
    return suggestions;
  }
  /**
   * 生成领域特定建议
   */
  async generateDomainSpecificSuggestions(query, category) {
    const suggestions = [];
    const domainTerms = {
      ["\u5FAE\u79EF\u5206" /* CALCULUS */]: ["\u5BFC\u6570", "\u79EF\u5206", "\u6781\u9650", "\u5FAE\u5206", "\u504F\u5BFC\u6570", "\u68AF\u5EA6"],
      ["\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */]: ["\u77E9\u9635", "\u5411\u91CF", "\u884C\u5217\u5F0F", "\u7279\u5F81\u503C", "\u7279\u5F81\u5411\u91CF", "\u7EBF\u6027\u53D8\u6362"],
      ["\u7EDF\u8BA1" /* STATISTICS */]: ["\u6982\u7387", "\u671F\u671B", "\u65B9\u5DEE", "\u6807\u51C6\u5DEE", "\u5206\u5E03", "\u5047\u8BBE\u68C0\u9A8C"],
      ["\u4EE3\u6570" /* ALGEBRA */]: ["\u591A\u9879\u5F0F", "\u65B9\u7A0B", "\u4E0D\u7B49\u5F0F", "\u51FD\u6570", "\u96C6\u5408", "\u6620\u5C04"],
      ["\u51E0\u4F55" /* GEOMETRY */]: ["\u70B9", "\u7EBF", "\u9762", "\u89D2", "\u4E09\u89D2\u5F62", "\u5706", "\u692D\u5706"],
      ["\u79BB\u6563\u6570\u5B66" /* DISCRETE_MATH */]: ["\u56FE\u8BBA", "\u7EC4\u5408", "\u9012\u63A8", "\u751F\u6210\u51FD\u6570", "\u7FA4\u8BBA"],
      ["\u6570\u8BBA" /* NUMBER_THEORY */]: ["\u8D28\u6570", "\u56E0\u6570", "\u540C\u4F59", "\u6B27\u62C9\u51FD\u6570", "\u8D39\u9A6C\u5B9A\u7406"],
      ["\u62D3\u6251\u5B66" /* TOPOLOGY */]: ["\u62D3\u6251\u7A7A\u95F4", "\u8FDE\u7EED\u6027", "\u7D27\u81F4\u6027", "\u8FDE\u901A\u6027"],
      ["\u6570\u5B66\u5206\u6790" /* ANALYSIS */]: ["\u5B9E\u5206\u6790", "\u590D\u5206\u6790", "\u6CDB\u51FD\u5206\u6790", "\u6D4B\u5EA6\u8BBA"],
      ["\u6982\u7387\u8BBA" /* PROBABILITY */]: ["\u968F\u673A\u53D8\u91CF", "\u6982\u7387\u5206\u5E03", "\u671F\u671B\u503C", "\u65B9\u5DEE"],
      ["\u96C6\u5408\u8BBA" /* SET_THEORY */]: ["\u96C6\u5408", "\u5B50\u96C6", "\u5E76\u96C6", "\u4EA4\u96C6", "\u8865\u96C6"],
      ["\u903B\u8F91" /* LOGIC */]: ["\u547D\u9898", "\u8C13\u8BCD", "\u91CF\u8BCD", "\u63A8\u7406", "\u8BC1\u660E"]
    };
    const terms = domainTerms[category] || [];
    for (const term of terms) {
      if (term.includes(query) || query.includes(term)) {
        const conversionResult = await this.neuralConverter.convertTerm(term);
        suggestions.push({
          text: term,
          latexCode: conversionResult.latexCode,
          description: `${category}\u76F8\u5173\u672F\u8BED`,
          score: 0.6,
          type: "term",
          category
        });
      }
    }
    return suggestions;
  }
  /**
   * 检查是否应该触发建议
   */
  shouldTriggerSuggestion(beforeCursor) {
    if (/[\u4e00-\u9fff]/.test(beforeCursor.slice(-1))) {
      return true;
    }
    if (/[\\$]/.test(beforeCursor.slice(-1))) {
      return true;
    }
    if (/[a-zA-Z]{2,}$/.test(beforeCursor)) {
      return true;
    }
    return false;
  }
  /**
   * 提取触发信息
   */
  extractTriggerInfo(beforeCursor, cursor) {
    let start = cursor.ch;
    let query = "";
    for (let i = cursor.ch - 1; i >= 0; i--) {
      const char = beforeCursor[i];
      if (/[\s\n\t,，。；;！!？?（）()【】\[\]{}]/.test(char)) {
        break;
      }
      start = i;
      query = char + query;
    }
    if (query.length < 1) return null;
    return {
      start: { line: cursor.line, ch: start },
      end: cursor,
      query
    };
  }
  /**
   * 异步更新上下文
   */
  async updateContextAsync(editor, file, cursor) {
    try {
      this.currentContext = await this.contextAnalyzer.analyzeContext(editor, file, cursor);
    } catch (error) {
      console.warn("SmartMathInput: \u4E0A\u4E0B\u6587\u5206\u6790\u5931\u8D25:", error);
      this.currentContext = null;
    }
  }
  /**
   * 生成缓存键
   */
  generateCacheKey(query, context) {
    const contextKey = context ? `${context.currentNote}-${context.detectedCategory}` : "no-context";
    return `${query}-${contextKey}`;
  }
  /**
   * 去重建议
   */
  deduplicateSuggestions(suggestions) {
    const seen = /* @__PURE__ */ new Set();
    return suggestions.filter((suggestion) => {
      const key = `${suggestion.text}-${suggestion.latexCode}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
  /**
   * 推断术语类别
   */
  inferCategory(term, context) {
    if (context == null ? void 0 : context.detectedCategory) {
      return context.detectedCategory;
    }
    if (term.includes("\u5BFC\u6570") || term.includes("\u79EF\u5206") || term.includes("\u6781\u9650")) {
      return "\u5FAE\u79EF\u5206" /* CALCULUS */;
    }
    if (term.includes("\u77E9\u9635") || term.includes("\u5411\u91CF")) {
      return "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */;
    }
    if (term.includes("\u6982\u7387") || term.includes("\u7EDF\u8BA1")) {
      return "\u7EDF\u8BA1" /* STATISTICS */;
    }
    return "\u4EE3\u6570" /* ALGEBRA */;
  }
  /**
   * 格式化术语插入
   */
  formatTermInsertion(suggestion) {
    if (suggestion.latexCode.includes("\\")) {
      return `$${suggestion.latexCode}$`;
    }
    return suggestion.latexCode;
  }
  /**
   * 格式化公式插入
   */
  formatFormulaInsertion(suggestion) {
    return `$$
${suggestion.latexCode}
$$`;
  }
  /**
   * 格式化模板插入
   */
  formatTemplateInsertion(suggestion) {
    return `$${suggestion.latexCode}$`;
  }
  /**
   * 查找替换范围
   */
  findReplaceRange(beforeCursor) {
    let range = "";
    for (let i = beforeCursor.length - 1; i >= 0; i--) {
      const char = beforeCursor[i];
      if (/[\s\n\t,，。；;！!？?（）()【】\[\]{}]/.test(char)) {
        break;
      }
      range = char + range;
    }
    return range;
  }
  /**
   * 智能光标定位
   */
  positionCursorAfterInsertion(editor, startPos, insertText, suggestion) {
    if (suggestion.type === "template" && insertText.includes("${")) {
      const firstPlaceholder = insertText.match(/\$\{1:([^}]*)\}/);
      if (firstPlaceholder) {
        const placeholderStart = insertText.indexOf(firstPlaceholder[0]);
        const placeholderContent = firstPlaceholder[1];
        const newPos2 = {
          line: startPos.line,
          ch: startPos.ch + placeholderStart + 4
          // 跳过 ${1:
        };
        editor.setSelection(newPos2, {
          line: newPos2.line,
          ch: newPos2.ch + placeholderContent.length
        });
        return;
      }
    }
    const newPos = {
      line: startPos.line,
      ch: startPos.ch + insertText.length
    };
    editor.setCursor(newPos);
  }
  /**
   * 获取类型显示名称
   */
  getTypeDisplayName(type) {
    const typeNames = {
      "term": "\u672F\u8BED",
      "formula": "\u516C\u5F0F",
      "template": "\u6A21\u677F"
    };
    return typeNames[type] || type;
  }
  /**
   * 显示激活通知
   */
  showActivationNotice() {
    const notice = document.createElement("div");
    notice.className = "smart-math-input-notice";
    notice.innerHTML = `
            <div class="notice-content">
                <span class="notice-icon">\u{1F9E0}</span>
                <span class="notice-text">AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u5DF2\u6FC0\u6D3B</span>
            </div>
        `;
    document.body.appendChild(notice);
    setTimeout(() => {
      if (notice.parentNode) {
        notice.parentNode.removeChild(notice);
      }
    }, 2e3);
  }
  /**
   * 更新性能指标
   */
  updatePerformanceMetrics(responseTime) {
    this.performanceMetrics.totalSuggestions++;
    this.performanceMetrics.averageResponseTime = (this.performanceMetrics.averageResponseTime + responseTime) / 2;
  }
  /**
   * 获取性能报告
   */
  getPerformanceReport() {
    return { ...this.performanceMetrics };
  }
};

// src/core/MainController.ts
var MainController = class {
  constructor(app, plugin, settings) {
    this.smartMathInput = null;
    this.isInitialized = false;
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.termRecognitionEngine = new TermRecognitionEngine(app);
    this.neuralLatexConverter = new NeuralLatexConverter(app);
    this.latexPreviewWidget = new LaTeXPreviewWidget(app, this.neuralLatexConverter);
    this.latexCopyHelper = new LaTeXCopyHelper(app, this.neuralLatexConverter);
  }
  async onload() {
    console.log("MainController: \u5F00\u59CB\u52A0\u8F7D\u63D2\u4EF6\u6838\u5FC3\u6A21\u5757...");
    try {
      await this.initializeCoreServices();
      this.registerEventHandlers();
      this.isInitialized = true;
      console.log("MainController: \u63D2\u4EF6\u6838\u5FC3\u6A21\u5757\u52A0\u8F7D\u5B8C\u6210");
    } catch (error) {
      console.error("MainController: \u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25:", error);
      new import_obsidian8.Notice("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u63A7\u5236\u53F0\u9519\u8BEF\u4FE1\u606F");
      throw error;
    }
  }
  onunload() {
    console.log("MainController: \u5F00\u59CB\u5378\u8F7D\u63D2\u4EF6\u6838\u5FC3\u6A21\u5757...");
    try {
      this.cleanup();
      this.isInitialized = false;
      console.log("MainController: \u63D2\u4EF6\u6838\u5FC3\u6A21\u5757\u5378\u8F7D\u5B8C\u6210");
    } catch (error) {
      console.error("MainController: \u63D2\u4EF6\u5378\u8F7D\u8FC7\u7A0B\u4E2D\u51FA\u73B0\u9519\u8BEF:", error);
    }
  }
  async loadSettings() {
    console.log("MainController: \u8BBE\u7F6E\u5DF2\u52A0\u8F7D");
  }
  async saveSettings() {
    console.log("MainController: \u8BBE\u7F6E\u5DF2\u4FDD\u5B58");
  }
  registerEventHandlers() {
    console.log("MainController: \u6CE8\u518C\u4E8B\u4EF6\u5904\u7406\u5668");
  }
  /**
   * 获取插件初始化状态
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * 获取当前设置
   */
  getSettings() {
    return this.settings;
  }
  /**
   * 更新设置
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
  }
  /**
   * 获取术语识别引擎
   */
  getTermRecognitionEngine() {
    return this.termRecognitionEngine;
  }
  /**
   * 获取神经网络LaTeX转换器
   */
  getNeuralLatexConverter() {
    return this.neuralLatexConverter;
  }
  /**
   * 获取LaTeX预览小部件
   */
  getLatexPreviewWidget() {
    return this.latexPreviewWidget;
  }
  /**
   * 获取LaTeX复制助手
   */
  getLatexCopyHelper() {
    return this.latexCopyHelper;
  }
  /**
   * 获取智能数学输入系统
   */
  getSmartMathInput() {
    return this.smartMathInput;
  }
  /**
   * 激活智能数学输入模式
   */
  activateSmartMathInput() {
    if (!this.isInitialized) {
      console.warn("MainController: \u63D2\u4EF6\u672A\u521D\u59CB\u5316\uFF0C\u65E0\u6CD5\u6FC0\u6D3B\u667A\u80FD\u8F93\u5165");
      return;
    }
    if (!this.smartMathInput) {
      console.warn("MainController: \u667A\u80FD\u8F93\u5165\u7CFB\u7EDF\u672A\u521D\u59CB\u5316");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
    if (!activeView) {
      new import_obsidian8.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2AMarkdown\u6587\u6863");
      return;
    }
    this.smartMathInput.activate(activeView.editor);
    new import_obsidian8.Notice("\u{1F9E0} AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u5DF2\u6FC0\u6D3B");
  }
  /**
   * 停用智能数学输入模式
   */
  deactivateSmartMathInput() {
    if (this.smartMathInput) {
      this.smartMathInput.deactivate();
      new import_obsidian8.Notice("\u23F9\uFE0F AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u5DF2\u505C\u7528");
    }
  }
  /**
   * 切换智能数学输入模式
   */
  toggleSmartMathInput() {
    if (!this.smartMathInput) {
      console.warn("MainController: \u667A\u80FD\u8F93\u5165\u7CFB\u7EDF\u672A\u521D\u59CB\u5316");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
    if (!activeView) {
      new import_obsidian8.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2AMarkdown\u6587\u6863");
      return;
    }
    try {
      this.smartMathInput.activate(activeView.editor);
      new import_obsidian8.Notice("\u{1F9E0} AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u5DF2\u6FC0\u6D3B");
    } catch (error) {
      this.smartMathInput.deactivate();
      new import_obsidian8.Notice("\u23F9\uFE0F AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u5DF2\u505C\u7528");
    }
  }
  /**
   * 手动触发术语识别
   */
  async recognizeTermsInCurrentNote() {
    if (!this.isInitialized) {
      console.warn("MainController: \u63D2\u4EF6\u672A\u521D\u59CB\u5316");
      return;
    }
    try {
      await this.termRecognitionEngine.markTermsInCurrentNote();
    } catch (error) {
      console.error("MainController: \u672F\u8BED\u8BC6\u522B\u5931\u8D25:", error);
      new import_obsidian8.Notice("\u672F\u8BED\u8BC6\u522B\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u63A7\u5236\u53F0\u9519\u8BEF\u4FE1\u606F");
    }
  }
  /**
   * 初始化核心服务
   */
  async initializeCoreServices() {
    console.log("MainController: \u521D\u59CB\u5316\u6838\u5FC3\u670D\u52A1...");
    this.validateObsidianEnvironment();
    await this.initializeDataStorage();
    await this.initializeTermRecognition();
    this.initializeLaTeXSupport();
    await this.initializeSmartMathInput();
    console.log("MainController: \u6838\u5FC3\u670D\u52A1\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 验证Obsidian环境
   */
  validateObsidianEnvironment() {
    if (!this.app) {
      throw new Error("Obsidian App\u5B9E\u4F8B\u4E0D\u53EF\u7528");
    }
    if (!this.app.workspace) {
      throw new Error("Obsidian Workspace\u4E0D\u53EF\u7528");
    }
    console.log("MainController: Obsidian\u73AF\u5883\u9A8C\u8BC1\u901A\u8FC7");
  }
  /**
   * 初始化数据存储
   */
  async initializeDataStorage() {
    console.log("MainController: \u521D\u59CB\u5316\u6570\u636E\u5B58\u50A8...");
    const dataDir = this.plugin.manifest.dir;
    if (!dataDir) {
      console.warn("MainController: \u65E0\u6CD5\u83B7\u53D6\u63D2\u4EF6\u6570\u636E\u76EE\u5F55");
    }
    console.log("MainController: \u6570\u636E\u5B58\u50A8\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 初始化术语识别引擎
   */
  async initializeTermRecognition() {
    console.log("MainController: \u521D\u59CB\u5316\u672F\u8BED\u8BC6\u522B\u5F15\u64CE...");
    try {
      await this.termRecognitionEngine.initialize();
      console.log("MainController: \u672F\u8BED\u8BC6\u522B\u5F15\u64CE\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("MainController: \u672F\u8BED\u8BC6\u522B\u5F15\u64CE\u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 初始化LaTeX支持
   */
  initializeLaTeXSupport() {
    console.log("MainController: \u521D\u59CB\u5316LaTeX\u6E32\u67D3\u652F\u6301...");
    if (typeof window !== "undefined" && window.MathJax) {
      console.log("MainController: \u68C0\u6D4B\u5230MathJax\u652F\u6301");
    } else {
      console.log("MainController: \u4F7F\u7528Obsidian\u5185\u7F6E\u6570\u5B66\u6E32\u67D3");
    }
    console.log("MainController: LaTeX\u652F\u6301\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 初始化智能数学输入系统
   */
  async initializeSmartMathInput() {
    console.log("MainController: \u521D\u59CB\u5316AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u7CFB\u7EDF...");
    try {
      if (!this.settings.enableMathInput) {
        console.log("MainController: \u667A\u80FD\u6570\u5B66\u8F93\u5165\u529F\u80FD\u5DF2\u7981\u7528");
        return;
      }
      if (!this.neuralLatexConverter) {
        throw new Error("\u795E\u7ECF\u7F51\u7EDCLaTeX\u8F6C\u6362\u5668\u672A\u521D\u59CB\u5316");
      }
      if (!this.termRecognitionEngine) {
        throw new Error("\u672F\u8BED\u8BC6\u522B\u5F15\u64CE\u672A\u521D\u59CB\u5316");
      }
      this.smartMathInput = new SmartMathInput(
        this.app,
        this.neuralLatexConverter,
        this.termRecognitionEngine
      );
      console.log("\u2705 MainController: AI\u667A\u80FD\u6570\u5B66\u8F93\u5165\u7CFB\u7EDF\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("MainController: \u667A\u80FD\u6570\u5B66\u8F93\u5165\u7CFB\u7EDF\u521D\u59CB\u5316\u5931\u8D25:", error);
      this.smartMathInput = null;
    }
  }
  /**
   * 清理资源
   */
  cleanup() {
    console.log("MainController: \u6E05\u7406\u8D44\u6E90...");
    if (this.termRecognitionEngine) {
      this.termRecognitionEngine.cleanup();
    }
    if (this.neuralLatexConverter) {
      this.neuralLatexConverter.unload();
    }
    if (this.latexPreviewWidget) {
      this.latexPreviewWidget.unload();
    }
    console.log("MainController: \u8D44\u6E90\u6E05\u7406\u5B8C\u6210");
  }
};

// src/storage/DatabaseManager.ts
var DatabaseManager = class {
  constructor(app, plugin) {
    this.isInitialized = false;
    // 内存缓存
    this.termsCache = /* @__PURE__ */ new Map();
    this.relationsCache = /* @__PURE__ */ new Map();
    this.lastSaveTime = 0;
    this.isDirty = false;
    this.app = app;
    this.plugin = plugin;
    this.dataPath = "math-memory-graph";
  }
  /**
   * 初始化数据库
   */
  async initialize() {
    console.log("DatabaseManager: \u5F00\u59CB\u521D\u59CB\u5316\u6570\u636E\u5B58\u50A8...");
    try {
      await this.ensureDataDirectory();
      await this.loadExistingData();
      this.startAutoSave();
      this.isInitialized = true;
      console.log("DatabaseManager: \u6570\u636E\u5B58\u50A8\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("DatabaseManager: \u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 保存术语
   */
  async saveTerm(term) {
    this.termsCache.set(term.id, { ...term, updatedAt: /* @__PURE__ */ new Date() });
    this.markDirty();
    if (this.shouldAutoSave()) {
      await this.persistData();
    }
  }
  /**
   * 获取术语
   */
  async getTerm(id) {
    return this.termsCache.get(id) || null;
  }
  /**
   * 获取所有术语
   */
  async getAllTerms() {
    return Array.from(this.termsCache.values());
  }
  /**
   * 按类别获取术语
   */
  async getTermsByCategory(category) {
    return Array.from(this.termsCache.values()).filter((term) => term.category === category);
  }
  /**
   * 更新术语
   */
  async updateTerm(term) {
    if (this.termsCache.has(term.id)) {
      await this.saveTerm(term);
    } else {
      throw new Error(`\u672F\u8BED ${term.id} \u4E0D\u5B58\u5728`);
    }
  }
  /**
   * 删除术语
   */
  async deleteTerm(id) {
    if (this.termsCache.has(id)) {
      this.termsCache.delete(id);
      const relatedRelations = Array.from(this.relationsCache.values()).filter((rel) => rel.sourceTermId === id || rel.targetTermId === id);
      for (const relation of relatedRelations) {
        this.relationsCache.delete(relation.id);
      }
      this.markDirty();
      if (this.shouldAutoSave()) {
        await this.persistData();
      }
    }
  }
  /**
   * 保存关系
   */
  async saveRelation(relation) {
    this.relationsCache.set(relation.id, { ...relation, lastUpdated: /* @__PURE__ */ new Date() });
    this.markDirty();
    if (this.shouldAutoSave()) {
      await this.persistData();
    }
  }
  /**
   * 获取关系
   */
  async getRelation(id) {
    return this.relationsCache.get(id) || null;
  }
  /**
   * 获取术语的所有关系
   */
  async getRelationsForTerm(termId) {
    return Array.from(this.relationsCache.values()).filter((rel) => rel.sourceTermId === termId || rel.targetTermId === termId);
  }
  /**
   * 更新关系
   */
  async updateRelation(relation) {
    if (this.relationsCache.has(relation.id)) {
      await this.saveRelation(relation);
    } else {
      throw new Error(`\u5173\u7CFB ${relation.id} \u4E0D\u5B58\u5728`);
    }
  }
  /**
   * 删除关系
   */
  async deleteRelation(id) {
    if (this.relationsCache.has(id)) {
      this.relationsCache.delete(id);
      this.markDirty();
      if (this.shouldAutoSave()) {
        await this.persistData();
      }
    }
  }
  /**
   * 获取术语统计
   */
  async getTermStatistics() {
    const terms = Array.from(this.termsCache.values());
    const categoryCounts = /* @__PURE__ */ new Map();
    for (const term of terms) {
      const count = categoryCounts.get(term.category) || 0;
      categoryCounts.set(term.category, count + 1);
    }
    const recentlyAdded = terms.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()).slice(0, 10);
    const mostUsedTerms = terms.slice(0, 10).map((term) => ({ term, count: 1 }));
    return {
      totalTerms: terms.length,
      categoryCounts,
      mostUsedTerms,
      recentlyAdded
    };
  }
  /**
   * 搜索术语
   */
  async searchTerms(query) {
    const lowercaseQuery = query.toLowerCase();
    return Array.from(this.termsCache.values()).filter(
      (term) => {
        var _a, _b;
        return term.chineseName.toLowerCase().includes(lowercaseQuery) || ((_a = term.englishName) == null ? void 0 : _a.toLowerCase().includes(lowercaseQuery)) || term.aliases.some((alias) => alias.toLowerCase().includes(lowercaseQuery)) || ((_b = term.definition) == null ? void 0 : _b.toLowerCase().includes(lowercaseQuery));
      }
    );
  }
  /**
   * 备份数据
   */
  async backup() {
    const backupData = {
      terms: Array.from(this.termsCache.entries()),
      relations: Array.from(this.relationsCache.entries()),
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.0.0"
    };
    const backupFileName = `backup-${Date.now()}.json`;
    const backupPath = `${this.dataPath}/backups/${backupFileName}`;
    await this.plugin.app.vault.adapter.write(
      backupPath,
      JSON.stringify(backupData, null, 2)
    );
    console.log(`DatabaseManager: \u6570\u636E\u5DF2\u5907\u4EFD\u5230 ${backupPath}`);
  }
  /**
   * 恢复数据
   */
  async restore(backupData) {
    try {
      const data = JSON.parse(backupData);
      if (!data.terms || !data.relations) {
        throw new Error("\u5907\u4EFD\u6570\u636E\u683C\u5F0F\u65E0\u6548");
      }
      this.termsCache.clear();
      this.relationsCache.clear();
      for (const [id, term] of data.terms) {
        this.termsCache.set(id, {
          ...term,
          createdAt: new Date(term.createdAt),
          updatedAt: new Date(term.updatedAt)
        });
      }
      for (const [id, relation] of data.relations) {
        this.relationsCache.set(id, {
          ...relation,
          createdAt: new Date(relation.createdAt),
          lastUpdated: new Date(relation.lastUpdated)
        });
      }
      await this.persistData();
      console.log("DatabaseManager: \u6570\u636E\u6062\u590D\u5B8C\u6210");
    } catch (error) {
      console.error("DatabaseManager: \u6570\u636E\u6062\u590D\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 清理数据
   */
  async cleanup() {
    const orphanedRelations = [];
    for (const [id, relation] of this.relationsCache) {
      if (!this.termsCache.has(relation.sourceTermId) || !this.termsCache.has(relation.targetTermId)) {
        orphanedRelations.push(id);
      }
    }
    for (const id of orphanedRelations) {
      this.relationsCache.delete(id);
    }
    if (orphanedRelations.length > 0) {
      this.markDirty();
      await this.persistData();
      console.log(`DatabaseManager: \u6E05\u7406\u4E86 ${orphanedRelations.length} \u4E2A\u5B64\u7ACB\u5173\u7CFB`);
    }
  }
  /**
   * 确保数据目录存在
   */
  async ensureDataDirectory() {
    const adapter = this.plugin.app.vault.adapter;
    if (!await adapter.exists(this.dataPath)) {
      await adapter.mkdir(this.dataPath);
    }
    const backupPath = `${this.dataPath}/backups`;
    if (!await adapter.exists(backupPath)) {
      await adapter.mkdir(backupPath);
    }
  }
  /**
   * 加载现有数据
   */
  async loadExistingData() {
    const adapter = this.plugin.app.vault.adapter;
    try {
      const termsPath = `${this.dataPath}/terms.json`;
      if (await adapter.exists(termsPath)) {
        const termsData = await adapter.read(termsPath);
        const terms = JSON.parse(termsData);
        for (const term of terms) {
          this.termsCache.set(term.id, {
            ...term,
            createdAt: new Date(term.createdAt),
            updatedAt: new Date(term.updatedAt)
          });
        }
      }
      const relationsPath = `${this.dataPath}/relations.json`;
      if (await adapter.exists(relationsPath)) {
        const relationsData = await adapter.read(relationsPath);
        const relations = JSON.parse(relationsData);
        for (const relation of relations) {
          this.relationsCache.set(relation.id, {
            ...relation,
            createdAt: new Date(relation.createdAt),
            lastUpdated: new Date(relation.lastUpdated)
          });
        }
      }
      console.log(`DatabaseManager: \u52A0\u8F7D\u4E86 ${this.termsCache.size} \u4E2A\u672F\u8BED\u548C ${this.relationsCache.size} \u4E2A\u5173\u7CFB`);
    } catch (error) {
      console.error("DatabaseManager: \u52A0\u8F7D\u6570\u636E\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 持久化数据到文件
   */
  async persistData() {
    if (!this.isDirty) return;
    const adapter = this.plugin.app.vault.adapter;
    try {
      const termsPath = `${this.dataPath}/terms.json`;
      const termsData = Array.from(this.termsCache.values());
      await adapter.write(termsPath, JSON.stringify(termsData, null, 2));
      const relationsPath = `${this.dataPath}/relations.json`;
      const relationsData = Array.from(this.relationsCache.values());
      await adapter.write(relationsPath, JSON.stringify(relationsData, null, 2));
      this.isDirty = false;
      this.lastSaveTime = Date.now();
      console.log("DatabaseManager: \u6570\u636E\u5DF2\u6301\u4E45\u5316");
    } catch (error) {
      console.error("DatabaseManager: \u6570\u636E\u6301\u4E45\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 标记数据为脏状态
   */
  markDirty() {
    this.isDirty = true;
  }
  /**
   * 检查是否应该自动保存
   */
  shouldAutoSave() {
    const now = Date.now();
    const timeSinceLastSave = now - this.lastSaveTime;
    return timeSinceLastSave > 5e3;
  }
  /**
   * 启动自动保存定时器
   */
  startAutoSave() {
    setInterval(async () => {
      if (this.isDirty) {
        try {
          await this.persistData();
        } catch (error) {
          console.error("DatabaseManager: \u81EA\u52A8\u4FDD\u5B58\u5931\u8D25:", error);
        }
      }
    }, 1e4);
  }
};

// src/storage/DataModelFactory.ts
var DataModelFactory = class {
  /**
   * 创建新的数学术语
   */
  static createMathTerm(data) {
    var _a, _b, _c;
    const now = /* @__PURE__ */ new Date();
    return {
      id: this.generateId("term"),
      chineseName: data.chineseName.trim(),
      englishName: (_a = data.englishName) == null ? void 0 : _a.trim(),
      category: data.category,
      latexCode: data.latexCode.trim(),
      definition: (_b = data.definition) == null ? void 0 : _b.trim(),
      aliases: ((_c = data.aliases) == null ? void 0 : _c.map((alias) => alias.trim())) || [],
      createdAt: now,
      updatedAt: now
    };
  }
  /**
   * 创建术语关系
   */
  static createTermRelation(data) {
    const now = /* @__PURE__ */ new Date();
    return {
      id: this.generateId("relation"),
      sourceTermId: data.sourceTermId,
      targetTermId: data.targetTermId,
      relationType: data.relationType,
      strength: data.strength || 1,
      noteIds: data.noteIds || [],
      createdAt: now,
      lastUpdated: now
    };
  }
  /**
   * 验证数学术语数据
   */
  static validateMathTerm(term) {
    const errors = [];
    const warnings = [];
    if (!term.chineseName || term.chineseName.trim().length === 0) {
      errors.push("\u4E2D\u6587\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (!term.category) {
      errors.push("\u672F\u8BED\u7C7B\u522B\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (!term.latexCode || term.latexCode.trim().length === 0) {
      errors.push("LaTeX\u4EE3\u7801\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (term.chineseName && term.chineseName.length > 100) {
      warnings.push("\u4E2D\u6587\u540D\u79F0\u8FC7\u957F\uFF0C\u5EFA\u8BAE\u63A7\u5236\u5728100\u5B57\u7B26\u4EE5\u5185");
    }
    if (term.englishName && term.englishName.length > 200) {
      warnings.push("\u82F1\u6587\u540D\u79F0\u8FC7\u957F\uFF0C\u5EFA\u8BAE\u63A7\u5236\u5728200\u5B57\u7B26\u4EE5\u5185");
    }
    if (term.definition && term.definition.length > 1e3) {
      warnings.push("\u5B9A\u4E49\u8FC7\u957F\uFF0C\u5EFA\u8BAE\u63A7\u5236\u57281000\u5B57\u7B26\u4EE5\u5185");
    }
    if (term.aliases && term.aliases.length > 20) {
      warnings.push("\u522B\u540D\u8FC7\u591A\uFF0C\u5EFA\u8BAE\u63A7\u5236\u572820\u4E2A\u4EE5\u5185");
    }
    if (term.latexCode) {
      const latexCode = term.latexCode.trim();
      if (!latexCode.startsWith("$") && !latexCode.startsWith("\\")) {
        warnings.push("LaTeX\u4EE3\u7801\u683C\u5F0F\u53EF\u80FD\u4E0D\u6B63\u786E");
      }
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * 验证术语关系数据
   */
  static validateTermRelation(relation) {
    const errors = [];
    const warnings = [];
    if (!relation.sourceTermId || relation.sourceTermId.trim().length === 0) {
      errors.push("\u6E90\u672F\u8BEDID\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (!relation.targetTermId || relation.targetTermId.trim().length === 0) {
      errors.push("\u76EE\u6807\u672F\u8BEDID\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (!relation.relationType) {
      errors.push("\u5173\u7CFB\u7C7B\u578B\u4E0D\u80FD\u4E3A\u7A7A");
    }
    if (relation.sourceTermId === relation.targetTermId) {
      errors.push("\u6E90\u672F\u8BED\u548C\u76EE\u6807\u672F\u8BED\u4E0D\u80FD\u76F8\u540C");
    }
    if (relation.strength !== void 0) {
      if (relation.strength < 0 || relation.strength > 1) {
        errors.push("\u5173\u7CFB\u5F3A\u5EA6\u5FC5\u987B\u57280\u52301\u4E4B\u95F4");
      }
      if (relation.strength < 0.1) {
        warnings.push("\u5173\u7CFB\u5F3A\u5EA6\u8FC7\u4F4E\uFF0C\u53EF\u80FD\u4E0D\u591F\u663E\u8457");
      }
    }
    if (relation.noteIds && relation.noteIds.length > 100) {
      warnings.push("\u5173\u8054\u7B14\u8BB0\u8FC7\u591A\uFF0C\u53EF\u80FD\u5F71\u54CD\u6027\u80FD");
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * 清理和标准化术语数据
   */
  static sanitizeMathTerm(term) {
    const sanitized = { ...term };
    if (sanitized.chineseName) {
      sanitized.chineseName = sanitized.chineseName.trim().replace(/\s+/g, " ");
    }
    if (sanitized.englishName) {
      sanitized.englishName = sanitized.englishName.trim().replace(/\s+/g, " ");
    }
    if (sanitized.latexCode) {
      sanitized.latexCode = sanitized.latexCode.trim();
    }
    if (sanitized.definition) {
      sanitized.definition = sanitized.definition.trim().replace(/\s+/g, " ");
    }
    if (sanitized.aliases) {
      sanitized.aliases = sanitized.aliases.map((alias) => alias.trim()).filter((alias) => alias.length > 0).filter((alias, index, arr) => arr.indexOf(alias) === index);
    }
    return sanitized;
  }
  /**
   * 清理和标准化关系数据
   */
  static sanitizeTermRelation(relation) {
    const sanitized = { ...relation };
    if (sanitized.sourceTermId) {
      sanitized.sourceTermId = sanitized.sourceTermId.trim();
    }
    if (sanitized.targetTermId) {
      sanitized.targetTermId = sanitized.targetTermId.trim();
    }
    if (sanitized.strength !== void 0) {
      sanitized.strength = Math.max(0, Math.min(1, sanitized.strength));
    }
    if (sanitized.noteIds) {
      sanitized.noteIds = sanitized.noteIds.map((id) => id.trim()).filter((id) => id.length > 0).filter((id, index, arr) => arr.indexOf(id) === index);
    }
    return sanitized;
  }
  /**
   * 生成唯一ID
   */
  static generateId(prefix) {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    return `${prefix}_${timestamp}_${random}`;
  }
  /**
   * 检查术语是否重复
   */
  static isDuplicateTerm(newTerm, existingTerms) {
    var _a, _b;
    const newNameLower = newTerm.chineseName.toLowerCase();
    const newEnglishLower = (_a = newTerm.englishName) == null ? void 0 : _a.toLowerCase();
    for (const existing of existingTerms) {
      if (existing.chineseName.toLowerCase() === newNameLower && existing.category === newTerm.category) {
        return {
          isDuplicate: true,
          duplicateType: "exact",
          conflictingTerm: existing
        };
      }
      if (newEnglishLower && ((_b = existing.englishName) == null ? void 0 : _b.toLowerCase()) === newEnglishLower && existing.category === newTerm.category) {
        return {
          isDuplicate: true,
          duplicateType: "exact",
          conflictingTerm: existing
        };
      }
      const allNewNames = [newTerm.chineseName, ...newTerm.aliases || []];
      const allExistingNames = [existing.chineseName, ...existing.aliases || []];
      for (const newName of allNewNames) {
        for (const existingName of allExistingNames) {
          if (newName.toLowerCase() === existingName.toLowerCase() && existing.category === newTerm.category) {
            return {
              isDuplicate: true,
              duplicateType: "similar",
              conflictingTerm: existing
            };
          }
        }
      }
    }
    return {
      isDuplicate: false,
      duplicateType: "none"
    };
  }
  /**
   * 合并重复术语
   */
  static mergeTerms(primary, secondary) {
    const merged = { ...primary };
    const allAliases = [
      ...primary.aliases || [],
      ...secondary.aliases || [],
      secondary.chineseName
    ];
    if (secondary.englishName && secondary.englishName !== primary.englishName) {
      allAliases.push(secondary.englishName);
    }
    merged.aliases = Array.from(new Set(allAliases)).filter((alias) => alias !== primary.chineseName && alias !== primary.englishName);
    if (!merged.definition && secondary.definition) {
      merged.definition = secondary.definition;
    } else if (merged.definition && secondary.definition && secondary.definition.length > merged.definition.length) {
      merged.definition = secondary.definition;
    }
    merged.updatedAt = /* @__PURE__ */ new Date();
    return merged;
  }
};

// src/storage/MigrationManager.ts
var MigrationManager = class {
  constructor(app, plugin, dataPath) {
    this.migrations = [];
    this.currentVersion = "1.0.0";
    this.app = app;
    this.plugin = plugin;
    this.dataPath = dataPath;
    this.initializeMigrations();
  }
  /**
   * 初始化所有迁移
   */
  initializeMigrations() {
    this.migrations = [
      {
        version: "1.0.0",
        description: "\u521D\u59CB\u6570\u636E\u7ED3\u6784",
        up: async (adapter) => {
          await this.createInitialStructure(adapter);
        }
      },
      {
        version: "1.1.0",
        description: "\u6DFB\u52A0\u672F\u8BED\u4F7F\u7528\u9891\u7387\u7EDF\u8BA1",
        up: async (adapter) => {
          await this.addUsageStatistics(adapter);
        }
      },
      {
        version: "1.2.0",
        description: "\u4F18\u5316\u5173\u7CFB\u5B58\u50A8\u7ED3\u6784",
        up: async (adapter) => {
          await this.optimizeRelationStorage(adapter);
        }
      }
    ];
  }
  /**
   * 执行数据迁移
   */
  async migrate() {
    console.log("MigrationManager: \u5F00\u59CB\u6570\u636E\u8FC1\u79FB\u68C0\u67E5...");
    const adapter = this.plugin.app.vault.adapter;
    const currentVersion = await this.getCurrentVersion(adapter);
    console.log(`MigrationManager: \u5F53\u524D\u7248\u672C ${currentVersion}, \u76EE\u6807\u7248\u672C ${this.currentVersion}`);
    if (this.needsMigration(currentVersion)) {
      await this.performMigration(adapter, currentVersion);
    } else {
      console.log("MigrationManager: \u65E0\u9700\u8FC1\u79FB");
    }
  }
  /**
   * 获取当前数据版本
   */
  async getCurrentVersion(adapter) {
    const versionPath = `${this.dataPath}/version.json`;
    try {
      if (await adapter.exists(versionPath)) {
        const versionData = await adapter.read(versionPath);
        const version = JSON.parse(versionData);
        return version.version || "0.0.0";
      }
    } catch (error) {
      console.warn("MigrationManager: \u65E0\u6CD5\u8BFB\u53D6\u7248\u672C\u4FE1\u606F:", error);
    }
    return "0.0.0";
  }
  /**
   * 保存版本信息
   */
  async saveVersion(adapter, version) {
    const versionPath = `${this.dataPath}/version.json`;
    const versionData = {
      version,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await adapter.write(versionPath, JSON.stringify(versionData, null, 2));
  }
  /**
   * 检查是否需要迁移
   */
  needsMigration(currentVersion) {
    return this.compareVersions(currentVersion, this.currentVersion) < 0;
  }
  /**
   * 执行迁移
   */
  async performMigration(adapter, fromVersion) {
    console.log(`MigrationManager: \u5F00\u59CB\u4ECE\u7248\u672C ${fromVersion} \u8FC1\u79FB\u5230 ${this.currentVersion}`);
    await this.createMigrationBackup(adapter);
    try {
      const migrationsToRun = this.migrations.filter(
        (migration) => this.compareVersions(fromVersion, migration.version) < 0 && this.compareVersions(migration.version, this.currentVersion) <= 0
      );
      for (const migration of migrationsToRun) {
        console.log(`MigrationManager: \u6267\u884C\u8FC1\u79FB ${migration.version} - ${migration.description}`);
        await migration.up(adapter);
      }
      await this.saveVersion(adapter, this.currentVersion);
      console.log("MigrationManager: \u8FC1\u79FB\u5B8C\u6210");
    } catch (error) {
      console.error("MigrationManager: \u8FC1\u79FB\u5931\u8D25:", error);
      throw new Error(`\u6570\u636E\u8FC1\u79FB\u5931\u8D25: ${error.message}`);
    }
  }
  /**
   * 创建迁移备份
   */
  async createMigrationBackup(adapter) {
    const backupPath = `${this.dataPath}/migration-backup-${Date.now()}`;
    try {
      const filesToBackup = ["terms.json", "relations.json", "version.json"];
      for (const file of filesToBackup) {
        const sourcePath = `${this.dataPath}/${file}`;
        const backupFilePath = `${backupPath}/${file}`;
        if (await adapter.exists(sourcePath)) {
          const data = await adapter.read(sourcePath);
          await adapter.write(backupFilePath, data);
        }
      }
      console.log(`MigrationManager: \u8FC1\u79FB\u5907\u4EFD\u5DF2\u521B\u5EFA: ${backupPath}`);
    } catch (error) {
      console.error("MigrationManager: \u521B\u5EFA\u5907\u4EFD\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 比较版本号
   */
  compareVersions(version1, version2) {
    const v1Parts = version1.split(".").map(Number);
    const v2Parts = version2.split(".").map(Number);
    const maxLength = Math.max(v1Parts.length, v2Parts.length);
    for (let i = 0; i < maxLength; i++) {
      const v1Part = v1Parts[i] || 0;
      const v2Part = v2Parts[i] || 0;
      if (v1Part < v2Part) return -1;
      if (v1Part > v2Part) return 1;
    }
    return 0;
  }
  /**
   * 创建初始数据结构 (v1.0.0)
   */
  async createInitialStructure(adapter) {
    if (!await adapter.exists(this.dataPath)) {
      await adapter.mkdir(this.dataPath);
    }
    const termsPath = `${this.dataPath}/terms.json`;
    if (!await adapter.exists(termsPath)) {
      await adapter.write(termsPath, "[]");
    }
    const relationsPath = `${this.dataPath}/relations.json`;
    if (!await adapter.exists(relationsPath)) {
      await adapter.write(relationsPath, "[]");
    }
    const configPath = `${this.dataPath}/config.json`;
    if (!await adapter.exists(configPath)) {
      const defaultConfig = {
        autoCleanup: true,
        maxBackups: 10,
        compressionEnabled: false
      };
      await adapter.write(configPath, JSON.stringify(defaultConfig, null, 2));
    }
  }
  /**
   * 添加使用频率统计 (v1.1.0)
   */
  async addUsageStatistics(adapter) {
    const termsPath = `${this.dataPath}/terms.json`;
    if (await adapter.exists(termsPath)) {
      const termsData = await adapter.read(termsPath);
      const terms = JSON.parse(termsData);
      const updatedTerms = terms.map((term) => ({
        ...term,
        usageCount: term.usageCount || 0,
        lastUsed: term.lastUsed || term.createdAt,
        usageHistory: term.usageHistory || []
      }));
      await adapter.write(termsPath, JSON.stringify(updatedTerms, null, 2));
    }
    const statsPath = `${this.dataPath}/statistics.json`;
    if (!await adapter.exists(statsPath)) {
      const defaultStats = {
        totalSearches: 0,
        totalRecognitions: 0,
        categoryUsage: {},
        dailyStats: {}
      };
      await adapter.write(statsPath, JSON.stringify(defaultStats, null, 2));
    }
  }
  /**
   * 优化关系存储结构 (v1.2.0)
   */
  async optimizeRelationStorage(adapter) {
    const relationsPath = `${this.dataPath}/relations.json`;
    if (await adapter.exists(relationsPath)) {
      const relationsData = await adapter.read(relationsPath);
      const relations = JSON.parse(relationsData);
      const optimizedRelations = relations.map((relation) => ({
        ...relation,
        // 添加索引字段以提高查询性能
        sourceIndex: relation.sourceTermId,
        targetIndex: relation.targetTermId,
        // 添加权重衰减机制
        decayFactor: relation.decayFactor || 0.95,
        // 添加上下文信息
        contextHash: this.generateContextHash(relation.noteIds || [])
      }));
      await adapter.write(relationsPath, JSON.stringify(optimizedRelations, null, 2));
    }
    const indexPath = `${this.dataPath}/relation-index.json`;
    if (!await adapter.exists(indexPath)) {
      await this.rebuildRelationIndex(adapter);
    }
  }
  /**
   * 重建关系索引
   */
  async rebuildRelationIndex(adapter) {
    const relationsPath = `${this.dataPath}/relations.json`;
    const indexPath = `${this.dataPath}/relation-index.json`;
    if (await adapter.exists(relationsPath)) {
      const relationsData = await adapter.read(relationsPath);
      const relations = JSON.parse(relationsData);
      const index = {};
      for (const relation of relations) {
        if (!index[relation.sourceTermId]) {
          index[relation.sourceTermId] = [];
        }
        index[relation.sourceTermId].push(relation.id);
        if (!index[relation.targetTermId]) {
          index[relation.targetTermId] = [];
        }
        index[relation.targetTermId].push(relation.id);
      }
      await adapter.write(indexPath, JSON.stringify(index, null, 2));
    }
  }
  /**
   * 生成上下文哈希
   */
  generateContextHash(noteIds) {
    if (noteIds.length === 0) return "";
    const sortedIds = noteIds.sort();
    const combined = sortedIds.join("|");
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
      const char = combined.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  /**
   * 回滚到指定版本
   */
  async rollback(targetVersion) {
    console.log(`MigrationManager: \u5F00\u59CB\u56DE\u6EDA\u5230\u7248\u672C ${targetVersion}`);
    const adapter = this.plugin.app.vault.adapter;
    const currentVersion = await this.getCurrentVersion(adapter);
    if (this.compareVersions(targetVersion, currentVersion) >= 0) {
      throw new Error("\u76EE\u6807\u7248\u672C\u4E0D\u80FD\u9AD8\u4E8E\u6216\u7B49\u4E8E\u5F53\u524D\u7248\u672C");
    }
    await this.createMigrationBackup(adapter);
    try {
      const migrationsToRollback = this.migrations.filter(
        (migration) => this.compareVersions(targetVersion, migration.version) < 0 && this.compareVersions(migration.version, currentVersion) <= 0
      ).reverse();
      for (const migration of migrationsToRollback) {
        if (migration.down) {
          console.log(`MigrationManager: \u56DE\u6EDA\u8FC1\u79FB ${migration.version}`);
          await migration.down(adapter);
        } else {
          console.warn(`MigrationManager: \u8FC1\u79FB ${migration.version} \u6CA1\u6709\u56DE\u6EDA\u65B9\u6CD5`);
        }
      }
      await this.saveVersion(adapter, targetVersion);
      console.log("MigrationManager: \u56DE\u6EDA\u5B8C\u6210");
    } catch (error) {
      console.error("MigrationManager: \u56DE\u6EDA\u5931\u8D25:", error);
      throw new Error(`\u6570\u636E\u56DE\u6EDA\u5931\u8D25: ${error.message}`);
    }
  }
};

// src/storage/DataAccessLayer.ts
var DataAccessLayer = class {
  constructor(databaseManager) {
    this.databaseManager = databaseManager;
  }
  /**
   * 智能添加术语（包含重复检测和合并）
   */
  async addTermSmart(termData) {
    try {
      const newTerm = DataModelFactory.createMathTerm(termData);
      const validation = DataModelFactory.validateMathTerm(newTerm);
      if (!validation.isValid) {
        return {
          success: false,
          warnings: validation.errors
        };
      }
      const existingTerms = await this.databaseManager.getAllTerms();
      const duplicateCheck = DataModelFactory.isDuplicateTerm(newTerm, existingTerms);
      if (duplicateCheck.isDuplicate) {
        if (duplicateCheck.duplicateType === "exact") {
          return {
            success: false,
            warnings: [`\u672F\u8BED "${newTerm.chineseName}" \u5DF2\u5B58\u5728`]
          };
        } else {
          const mergedTerm = DataModelFactory.mergeTerms(
            duplicateCheck.conflictingTerm,
            newTerm
          );
          await this.databaseManager.updateTerm(mergedTerm);
          return {
            success: true,
            term: mergedTerm,
            merged: true,
            warnings: validation.warnings
          };
        }
      }
      await this.databaseManager.saveTerm(newTerm);
      return {
        success: true,
        term: newTerm,
        merged: false,
        warnings: validation.warnings
      };
    } catch (error) {
      console.error("DataAccessLayer: \u6DFB\u52A0\u672F\u8BED\u5931\u8D25:", error);
      return {
        success: false,
        warnings: [`\u6DFB\u52A0\u672F\u8BED\u5931\u8D25: ${error.message}`]
      };
    }
  }
  /**
   * 智能创建术语关系
   */
  async createRelationSmart(relationData) {
    try {
      const sourceTerm = await this.databaseManager.getTerm(relationData.sourceTermId);
      const targetTerm = await this.databaseManager.getTerm(relationData.targetTermId);
      if (!sourceTerm || !targetTerm) {
        return {
          success: false,
          warnings: ["\u6E90\u672F\u8BED\u6216\u76EE\u6807\u672F\u8BED\u4E0D\u5B58\u5728"]
        };
      }
      const existingRelations = await this.databaseManager.getRelationsForTerm(relationData.sourceTermId);
      const duplicateRelation = existingRelations.find(
        (rel) => rel.targetTermId === relationData.targetTermId && rel.relationType === relationData.relationType
      );
      if (duplicateRelation) {
        const updatedRelation = {
          ...duplicateRelation,
          strength: Math.min(1, (duplicateRelation.strength + (relationData.strength || 1)) / 2),
          noteIds: Array.from(/* @__PURE__ */ new Set([
            ...duplicateRelation.noteIds,
            ...relationData.noteIds || []
          ])),
          lastUpdated: /* @__PURE__ */ new Date()
        };
        await this.databaseManager.updateRelation(updatedRelation);
        return {
          success: true,
          relation: updatedRelation,
          warnings: ["\u5173\u7CFB\u5DF2\u5B58\u5728\uFF0C\u5DF2\u66F4\u65B0\u5F3A\u5EA6"]
        };
      }
      const newRelation = DataModelFactory.createTermRelation(relationData);
      const validation = DataModelFactory.validateTermRelation(newRelation);
      if (!validation.isValid) {
        return {
          success: false,
          warnings: validation.errors
        };
      }
      await this.databaseManager.saveRelation(newRelation);
      return {
        success: true,
        relation: newRelation,
        warnings: validation.warnings
      };
    } catch (error) {
      console.error("DataAccessLayer: \u521B\u5EFA\u5173\u7CFB\u5931\u8D25:", error);
      return {
        success: false,
        warnings: [`\u521B\u5EFA\u5173\u7CFB\u5931\u8D25: ${error.message}`]
      };
    }
  }
  /**
   * 获取术语的扩展信息（包含关系和统计）
   */
  async getTermExtended(termId) {
    const term = await this.databaseManager.getTerm(termId);
    if (!term) {
      return {
        term: null,
        relations: [],
        relatedTerms: []
      };
    }
    const relations = await this.databaseManager.getRelationsForTerm(termId);
    const relatedTermIds = /* @__PURE__ */ new Set();
    relations.forEach((rel) => {
      if (rel.sourceTermId === termId) {
        relatedTermIds.add(rel.targetTermId);
      } else {
        relatedTermIds.add(rel.sourceTermId);
      }
    });
    const relatedTerms = [];
    for (const id of relatedTermIds) {
      const relatedTerm = await this.databaseManager.getTerm(id);
      if (relatedTerm) {
        relatedTerms.push(relatedTerm);
      }
    }
    const strongestRelations = relations.sort((a, b) => b.strength - a.strength).slice(0, 5);
    const categoryDistribution = /* @__PURE__ */ new Map();
    relatedTerms.forEach((relatedTerm) => {
      const count = categoryDistribution.get(relatedTerm.category) || 0;
      categoryDistribution.set(relatedTerm.category, count + 1);
    });
    return {
      term,
      relations,
      relatedTerms,
      usageStats: {
        totalRelations: relations.length,
        strongestRelations,
        categoryDistribution
      }
    };
  }
  /**
   * 智能搜索术语（支持模糊匹配和相关性排序）
   */
  async searchTermsSmart(query, options) {
    const limit = (options == null ? void 0 : options.limit) || 20;
    let directMatches = await this.databaseManager.searchTerms(query);
    if (options == null ? void 0 : options.category) {
      directMatches = directMatches.filter((term) => term.category === options.category);
    }
    directMatches = directMatches.slice(0, limit);
    let relatedMatches = [];
    let suggestions = [];
    if ((options == null ? void 0 : options.includeRelated) && directMatches.length > 0) {
      const relatedTermIds = /* @__PURE__ */ new Set();
      for (const term of directMatches.slice(0, 5)) {
        const relations = await this.databaseManager.getRelationsForTerm(term.id);
        relations.forEach((rel) => {
          if (rel.sourceTermId === term.id) {
            relatedTermIds.add(rel.targetTermId);
          } else {
            relatedTermIds.add(rel.sourceTermId);
          }
        });
      }
      for (const id of Array.from(relatedTermIds).slice(0, 10)) {
        const relatedTerm = await this.databaseManager.getTerm(id);
        if (relatedTerm && !directMatches.find((t) => t.id === id)) {
          relatedMatches.push(relatedTerm);
        }
      }
    }
    if (directMatches.length === 0) {
      const allTerms = await this.databaseManager.getAllTerms();
      suggestions = this.generateSearchSuggestions(query, allTerms);
    }
    return {
      directMatches,
      relatedMatches,
      suggestions
    };
  }
  /**
   * 获取类别统计和趋势
   */
  async getCategoryAnalytics() {
    var _a;
    const stats = await this.databaseManager.getTermStatistics();
    const allTerms = await this.databaseManager.getAllTerms();
    const categoryStats = /* @__PURE__ */ new Map();
    for (const [category, count] of stats.categoryCounts) {
      const categoryTerms = allTerms.filter((term) => term.category === category);
      let totalRelations = 0;
      for (const term of categoryTerms) {
        const relations = await this.databaseManager.getRelationsForTerm(term.id);
        totalRelations += relations.length;
      }
      const avgRelations = categoryTerms.length > 0 ? totalRelations / categoryTerms.length : 0;
      const recentTerms2 = categoryTerms.filter((term) => {
        const daysSinceCreated = (Date.now() - term.createdAt.getTime()) / (1e3 * 60 * 60 * 24);
        return daysSinceCreated <= 30;
      });
      const recentGrowth = recentTerms2.length;
      const termsWithRelationCount = await Promise.all(
        categoryTerms.map(async (term) => {
          const relations = await this.databaseManager.getRelationsForTerm(term.id);
          return { term, relationCount: relations.length };
        })
      );
      const topTerms = termsWithRelationCount.sort((a, b) => b.relationCount - a.relationCount).slice(0, 5).map((item) => item.term);
      categoryStats.set(category, {
        count,
        recentGrowth,
        avgRelations,
        topTerms
      });
    }
    const mostActiveCategory = ((_a = Array.from(stats.categoryCounts.entries()).sort(([, a], [, b]) => b - a)[0]) == null ? void 0 : _a[0]) || "\u4EE3\u6570" /* ALGEBRA */;
    const recentTerms = allTerms.filter((term) => {
      const daysSinceCreated = (Date.now() - term.createdAt.getTime()) / (1e3 * 60 * 60 * 24);
      return daysSinceCreated <= 7;
    });
    let recentRelationsCount = 0;
    for (const term of recentTerms) {
      const relations = await this.databaseManager.getRelationsForTerm(term.id);
      recentRelationsCount += relations.filter((rel) => {
        const daysSinceCreated = (Date.now() - rel.createdAt.getTime()) / (1e3 * 60 * 60 * 24);
        return daysSinceCreated <= 7;
      }).length;
    }
    return {
      categoryStats,
      overallTrends: {
        totalTerms: stats.totalTerms,
        totalRelations: recentRelationsCount,
        // 这里应该是总关系数，但为了简化使用最近的
        mostActiveCategory,
        recentActivity: {
          newTerms: recentTerms.length,
          newRelations: recentRelationsCount,
          period: "\u6700\u8FD17\u5929"
        }
      }
    };
  }
  /**
   * 数据清理和优化
   */
  async optimizeData() {
    console.log("DataAccessLayer: \u5F00\u59CB\u6570\u636E\u4F18\u5316...");
    await this.databaseManager.cleanup();
    return {
      cleaned: {
        orphanedRelations: 0,
        // 实际数量需要从cleanup方法返回
        duplicateTerms: 0,
        emptyDefinitions: 0
      },
      optimized: {
        relationStrengthsUpdated: 0,
        indexesRebuilt: true
      }
    };
  }
  /**
   * 生成搜索建议
   */
  generateSearchSuggestions(query, allTerms) {
    const suggestions = [];
    const queryLower = query.toLowerCase();
    for (const term of allTerms) {
      const names = [term.chineseName, term.englishName, ...term.aliases].filter(Boolean);
      for (const name of names) {
        if (name && this.calculateEditDistance(queryLower, name.toLowerCase()) <= 2) {
          suggestions.push(name);
          if (suggestions.length >= 5) break;
        }
      }
      if (suggestions.length >= 5) break;
    }
    return suggestions;
  }
  /**
   * 计算编辑距离（简化版）
   */
  calculateEditDistance(str1, str2) {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,
          matrix[j - 1][i] + 1,
          matrix[j - 1][i - 1] + indicator
        );
      }
    }
    return matrix[str2.length][str1.length];
  }
};

// src/ui/TermManagementView.ts
var import_obsidian12 = require("obsidian");

// src/ui/TermEditModal.ts
var import_obsidian9 = require("obsidian");
var TermEditModal = class extends import_obsidian9.Modal {
  constructor(app, term, onSave) {
    super(app);
    this.formData = {};
    this.term = term;
    this.onSave = onSave;
    if (term) {
      this.formData = { ...term };
    } else {
      this.formData = {
        id: this.generateId(),
        chineseName: "",
        englishName: "",
        category: "\u4EE3\u6570" /* ALGEBRA */,
        latexCode: "",
        definition: "",
        aliases: [],
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
    }
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.textContent = this.term ? "\u7F16\u8F91\u672F\u8BED" : "\u6DFB\u52A0\u65B0\u672F\u8BED";
    contentEl.empty();
    contentEl.addClass("term-edit-modal");
    this.renderForm();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * 渲染表单
   */
  renderForm() {
    const { contentEl } = this;
    new import_obsidian9.Setting(contentEl).setName("\u4E2D\u6587\u540D\u79F0 *").setDesc("\u672F\u8BED\u7684\u4E2D\u6587\u540D\u79F0").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1A\u5BFC\u6570").setValue(this.formData.chineseName || "").onChange((value) => {
      this.formData.chineseName = value;
    }));
    new import_obsidian9.Setting(contentEl).setName("\u82F1\u6587\u540D\u79F0").setDesc("\u672F\u8BED\u7684\u82F1\u6587\u540D\u79F0\uFF08\u53EF\u9009\uFF09").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1ADerivative").setValue(this.formData.englishName || "").onChange((value) => {
      this.formData.englishName = value;
    }));
    new import_obsidian9.Setting(contentEl).setName("\u5206\u7C7B *").setDesc("\u9009\u62E9\u672F\u8BED\u6240\u5C5E\u7684\u6570\u5B66\u5206\u7C7B").addDropdown((dropdown) => {
      Object.values(MathCategory).forEach((category) => {
        dropdown.addOption(category, category);
      });
      dropdown.setValue(this.formData.category || "\u4EE3\u6570" /* ALGEBRA */);
      dropdown.onChange((value) => {
        this.formData.category = value;
      });
    });
    new import_obsidian9.Setting(contentEl).setName("LaTeX\u4EE3\u7801").setDesc("\u672F\u8BED\u5BF9\u5E94\u7684LaTeX\u8868\u793A").addTextArea((text) => text.setPlaceholder("\u4F8B\u5982\uFF1A\\frac{d}{dx}").setValue(this.formData.latexCode || "").onChange((value) => {
      this.formData.latexCode = value;
    }));
    new import_obsidian9.Setting(contentEl).setName("\u5B9A\u4E49").setDesc("\u672F\u8BED\u7684\u6570\u5B66\u5B9A\u4E49\u6216\u8BF4\u660E").addTextArea((text) => text.setPlaceholder("\u8F93\u5165\u672F\u8BED\u7684\u5B9A\u4E49...").setValue(this.formData.definition || "").onChange((value) => {
      this.formData.definition = value;
    }));
    new import_obsidian9.Setting(contentEl).setName("\u522B\u540D").setDesc("\u672F\u8BED\u7684\u5176\u4ED6\u540D\u79F0\uFF0C\u7528\u9017\u53F7\u5206\u9694").addTextArea((text) => {
      var _a;
      return text.setPlaceholder("\u4F8B\u5982\uFF1A\u5FAE\u5206,\u6C42\u5BFC").setValue(((_a = this.formData.aliases) == null ? void 0 : _a.join(", ")) || "").onChange((value) => {
        this.formData.aliases = value.split(",").map((alias) => alias.trim()).filter((alias) => alias.length > 0);
      });
    });
    this.renderLatexPreview();
    this.renderButtons();
  }
  /**
   * 渲染LaTeX预览
   */
  renderLatexPreview() {
    const { contentEl } = this;
    const previewContainer = contentEl.createDiv("latex-preview-container");
    previewContainer.createEl("h4", { text: "LaTeX\u9884\u89C8" });
    const previewEl = previewContainer.createDiv("latex-preview");
    const updatePreview = () => {
      var _a, _b, _c;
      if (this.formData.latexCode) {
        previewEl.innerHTML = `$$${this.formData.latexCode}$$`;
        if ((_c = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-latex"]) == null ? void 0 : _c.renderMath) {
          this.app.plugins.plugins["obsidian-latex"].renderMath(previewEl);
        }
      } else {
        previewEl.textContent = "\u8F93\u5165LaTeX\u4EE3\u7801\u4EE5\u67E5\u770B\u9884\u89C8";
      }
    };
    updatePreview();
    const latexInput = contentEl.querySelector('textarea[placeholder*="LaTeX"]');
    if (latexInput) {
      latexInput.addEventListener("input", updatePreview);
    }
  }
  /**
   * 渲染按钮
   */
  renderButtons() {
    const { contentEl } = this;
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const cancelBtn = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const saveBtn = buttonContainer.createEl("button", { text: "\u4FDD\u5B58" });
    saveBtn.addClass("mod-cta");
    saveBtn.addEventListener("click", async () => {
      await this.handleSave();
    });
    if (this.term) {
      const previewBtn = buttonContainer.createEl("button", { text: "\u5728\u7B14\u8BB0\u4E2D\u9884\u89C8" });
      previewBtn.addEventListener("click", () => {
        this.previewInNote();
      });
    }
  }
  /**
   * 处理保存
   */
  async handleSave() {
    var _a, _b, _c, _d;
    if (!((_a = this.formData.chineseName) == null ? void 0 : _a.trim())) {
      new import_obsidian9.Notice("\u8BF7\u8F93\u5165\u4E2D\u6587\u540D\u79F0");
      return;
    }
    if (!this.formData.category) {
      new import_obsidian9.Notice("\u8BF7\u9009\u62E9\u5206\u7C7B");
      return;
    }
    try {
      const termToSave = {
        id: this.formData.id || this.generateId(),
        chineseName: this.formData.chineseName.trim(),
        englishName: ((_b = this.formData.englishName) == null ? void 0 : _b.trim()) || void 0,
        category: this.formData.category,
        latexCode: ((_c = this.formData.latexCode) == null ? void 0 : _c.trim()) || "",
        definition: ((_d = this.formData.definition) == null ? void 0 : _d.trim()) || void 0,
        aliases: this.formData.aliases || [],
        createdAt: this.formData.createdAt || /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      await this.onSave(termToSave);
      this.close();
    } catch (error) {
      console.error("\u4FDD\u5B58\u672F\u8BED\u5931\u8D25:", error);
      new import_obsidian9.Notice("\u4FDD\u5B58\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u8F93\u5165\u5185\u5BB9");
    }
  }
  /**
   * 在笔记中预览术语
   */
  previewInNote() {
    if (!this.formData.chineseName) {
      new import_obsidian9.Notice("\u8BF7\u5148\u8F93\u5165\u672F\u8BED\u540D\u79F0");
      return;
    }
    let previewContent = `# ${this.formData.chineseName}

`;
    if (this.formData.englishName) {
      previewContent += `**\u82F1\u6587\u540D\u79F0**: ${this.formData.englishName}

`;
    }
    previewContent += `**\u5206\u7C7B**: ${this.formData.category}

`;
    if (this.formData.latexCode) {
      previewContent += `**LaTeX**: $${this.formData.latexCode}$

`;
    }
    if (this.formData.definition) {
      previewContent += `**\u5B9A\u4E49**: ${this.formData.definition}

`;
    }
    if (this.formData.aliases && this.formData.aliases.length > 0) {
      previewContent += `**\u522B\u540D**: ${this.formData.aliases.join(", ")}

`;
    }
    const fileName = `\u672F\u8BED\u9884\u89C8-${this.formData.chineseName}.md`;
    this.app.vault.create(fileName, previewContent).then((file) => {
      this.app.workspace.getLeaf().openFile(file);
      new import_obsidian9.Notice("\u9884\u89C8\u6587\u4EF6\u5DF2\u521B\u5EFA");
    }).catch((error) => {
      console.error("\u521B\u5EFA\u9884\u89C8\u6587\u4EF6\u5931\u8D25:", error);
      new import_obsidian9.Notice("\u521B\u5EFA\u9884\u89C8\u6587\u4EF6\u5931\u8D25");
    });
  }
  /**
   * 生成唯一ID
   */
  generateId() {
    return `term_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/ui/TermDetailModal.ts
var import_obsidian10 = require("obsidian");
var TermDetailModal = class _TermDetailModal extends import_obsidian10.Modal {
  constructor(app, term, databaseManager) {
    super(app);
    this.relations = [];
    this.relatedTerms = [];
    this.term = term;
    this.databaseManager = databaseManager;
  }
  async onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.textContent = `\u672F\u8BED\u8BE6\u60C5 - ${this.term.chineseName}`;
    contentEl.empty();
    contentEl.addClass("term-detail-modal");
    await this.loadRelatedData();
    this.renderContent();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * 加载关联数据
   */
  async loadRelatedData() {
    try {
      this.relations = await this.databaseManager.getRelationsForTerm(this.term.id);
      const relatedTermIds = /* @__PURE__ */ new Set();
      this.relations.forEach((relation) => {
        if (relation.sourceTermId !== this.term.id) {
          relatedTermIds.add(relation.sourceTermId);
        }
        if (relation.targetTermId !== this.term.id) {
          relatedTermIds.add(relation.targetTermId);
        }
      });
      this.relatedTerms = [];
      for (const termId of relatedTermIds) {
        const term = await this.databaseManager.getTerm(termId);
        if (term) {
          this.relatedTerms.push(term);
        }
      }
    } catch (error) {
      console.error("\u52A0\u8F7D\u5173\u8054\u6570\u636E\u5931\u8D25:", error);
    }
  }
  /**
   * 渲染内容
   */
  renderContent() {
    const { contentEl } = this;
    this.renderBasicInfo(contentEl);
    this.renderLatexPreview(contentEl);
    this.renderRelationships(contentEl);
    this.renderActions(contentEl);
  }
  /**
   * 渲染基本信息
   */
  renderBasicInfo(container) {
    const infoSection = container.createDiv("term-basic-info");
    infoSection.createEl("h3", { text: "\u57FA\u672C\u4FE1\u606F" });
    const infoGrid = infoSection.createDiv("info-grid");
    const chineseNameRow = infoGrid.createDiv("info-row");
    chineseNameRow.createSpan({ text: "\u4E2D\u6587\u540D\u79F0:", cls: "info-label" });
    chineseNameRow.createSpan({ text: this.term.chineseName, cls: "info-value chinese-name" });
    if (this.term.englishName) {
      const englishNameRow = infoGrid.createDiv("info-row");
      englishNameRow.createSpan({ text: "\u82F1\u6587\u540D\u79F0:", cls: "info-label" });
      englishNameRow.createSpan({ text: this.term.englishName, cls: "info-value english-name" });
    }
    const categoryRow = infoGrid.createDiv("info-row");
    categoryRow.createSpan({ text: "\u5206\u7C7B:", cls: "info-label" });
    const categoryBadge = categoryRow.createSpan({ text: this.term.category, cls: "info-value category-badge" });
    categoryBadge.addClass(`category-${this.term.category.replace(/\s+/g, "-").toLowerCase()}`);
    if (this.term.aliases && this.term.aliases.length > 0) {
      const aliasesRow = infoGrid.createDiv("info-row");
      aliasesRow.createSpan({ text: "\u522B\u540D:", cls: "info-label" });
      const aliasesContainer = aliasesRow.createSpan({ cls: "info-value aliases-container" });
      this.term.aliases.forEach((alias, index) => {
        if (index > 0) {
          aliasesContainer.createSpan({ text: ", " });
        }
        aliasesContainer.createSpan({ text: alias, cls: "alias-tag" });
      });
    }
    if (this.term.definition) {
      const definitionSection = infoSection.createDiv("definition-section");
      definitionSection.createEl("h4", { text: "\u5B9A\u4E49" });
      const definitionContent = definitionSection.createDiv("definition-content");
      definitionContent.textContent = this.term.definition;
    }
    const timeInfo = infoSection.createDiv("time-info");
    timeInfo.createEl("small", {
      text: `\u521B\u5EFA\u65F6\u95F4: ${this.formatDate(this.term.createdAt)}`
    });
    timeInfo.createEl("br");
    timeInfo.createEl("small", {
      text: `\u66F4\u65B0\u65F6\u95F4: ${this.formatDate(this.term.updatedAt)}`
    });
  }
  /**
   * 渲染LaTeX预览
   */
  renderLatexPreview(container) {
    var _a, _b, _c;
    if (!this.term.latexCode) return;
    const latexSection = container.createDiv("latex-preview-section");
    latexSection.createEl("h3", { text: "LaTeX\u8868\u793A" });
    const codeContainer = latexSection.createDiv("latex-code-container");
    codeContainer.createEl("h4", { text: "\u4EE3\u7801" });
    const codeEl = codeContainer.createEl("code", { text: this.term.latexCode });
    codeEl.addClass("latex-code");
    const copyBtn = codeContainer.createEl("button", { text: "\u590D\u5236" });
    copyBtn.addClass("copy-latex-btn");
    copyBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(this.term.latexCode).then(() => {
        new import_obsidian10.Notice("LaTeX\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F");
      });
    });
    const previewContainer = latexSection.createDiv("latex-render-container");
    previewContainer.createEl("h4", { text: "\u9884\u89C8" });
    const previewEl = previewContainer.createDiv("latex-render");
    try {
      previewEl.innerHTML = `$$${this.term.latexCode}$$`;
      if ((_c = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-latex"]) == null ? void 0 : _c.renderMath) {
        this.app.plugins.plugins["obsidian-latex"].renderMath(previewEl);
      }
    } catch (error) {
      previewEl.textContent = "LaTeX\u6E32\u67D3\u5931\u8D25";
      previewEl.addClass("render-error");
    }
  }
  /**
   * 渲染关系网络
   */
  renderRelationships(container) {
    const relationSection = container.createDiv("relationships-section");
    relationSection.createEl("h3", { text: "\u5173\u7CFB\u7F51\u7EDC" });
    if (this.relations.length === 0) {
      relationSection.createEl("p", {
        text: "\u6682\u65E0\u76F8\u5173\u672F\u8BED",
        cls: "no-relations"
      });
      return;
    }
    const relationsByType = /* @__PURE__ */ new Map();
    this.relations.forEach((relation) => {
      const type = relation.relationType;
      if (!relationsByType.has(type)) {
        relationsByType.set(type, []);
      }
      relationsByType.get(type).push(relation);
    });
    relationsByType.forEach((relations, type) => {
      const typeSection = relationSection.createDiv("relation-type-section");
      typeSection.createEl("h4", { text: `${type} (${relations.length})` });
      const relationsList = typeSection.createDiv("relations-list");
      relations.forEach((relation) => {
        const relatedTermId = relation.sourceTermId === this.term.id ? relation.targetTermId : relation.sourceTermId;
        const relatedTerm = this.relatedTerms.find((t) => t.id === relatedTermId);
        if (!relatedTerm) return;
        const relationItem = relationsList.createDiv("relation-item");
        const termInfo = relationItem.createDiv("related-term-info");
        termInfo.createSpan({ text: relatedTerm.chineseName, cls: "related-term-name" });
        if (relatedTerm.englishName) {
          termInfo.createSpan({ text: ` (${relatedTerm.englishName})`, cls: "related-term-english" });
        }
        termInfo.createSpan({ text: relatedTerm.category, cls: "related-term-category" });
        const strengthBar = relationItem.createDiv("relation-strength");
        const strengthFill = strengthBar.createDiv("strength-fill");
        strengthFill.style.width = `${relation.strength * 100}%`;
        strengthBar.title = `\u5173\u7CFB\u5F3A\u5EA6: ${(relation.strength * 100).toFixed(1)}%`;
        relationItem.addEventListener("click", () => {
          new _TermDetailModal(this.app, relatedTerm, this.databaseManager).open();
        });
        relationItem.addClass("clickable");
      });
    });
  }
  /**
   * 渲染操作按钮
   */
  renderActions(container) {
    const actionsContainer = container.createDiv("term-detail-actions");
    const editBtn = actionsContainer.createEl("button", { text: "\u7F16\u8F91\u672F\u8BED" });
    editBtn.addClass("mod-cta");
    editBtn.addEventListener("click", () => {
      this.close();
      this.app.workspace.trigger("math-memory-graph:edit-term", this.term);
    });
    const createNoteBtn = actionsContainer.createEl("button", { text: "\u521B\u5EFA\u672F\u8BED\u7B14\u8BB0" });
    createNoteBtn.addEventListener("click", () => {
      this.createTermNote();
    });
    const viewInGraphBtn = actionsContainer.createEl("button", { text: "\u5728\u56FE\u8C31\u4E2D\u67E5\u770B" });
    viewInGraphBtn.addEventListener("click", () => {
      this.app.workspace.trigger("math-memory-graph:view-in-graph", this.term.id);
      this.close();
    });
    const closeBtn = actionsContainer.createEl("button", { text: "\u5173\u95ED" });
    closeBtn.addEventListener("click", () => {
      this.close();
    });
  }
  /**
   * 创建术语笔记
   */
  async createTermNote() {
    try {
      const fileName = `${this.term.chineseName}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(fileName);
      if (existingFile) {
        new import_obsidian10.Notice("\u8BE5\u672F\u8BED\u7684\u7B14\u8BB0\u5DF2\u5B58\u5728");
        if (existingFile instanceof import_obsidian10.TFile) {
          await this.app.workspace.getLeaf().openFile(existingFile);
        }
        return;
      }
      let content = `# ${this.term.chineseName}

`;
      if (this.term.englishName) {
        content += `**\u82F1\u6587\u540D\u79F0**: ${this.term.englishName}

`;
      }
      content += `**\u5206\u7C7B**: ${this.term.category}

`;
      if (this.term.latexCode) {
        content += `**LaTeX\u8868\u793A**: $${this.term.latexCode}$

`;
      }
      if (this.term.definition) {
        content += `## \u5B9A\u4E49

${this.term.definition}

`;
      }
      if (this.term.aliases && this.term.aliases.length > 0) {
        content += `**\u522B\u540D**: ${this.term.aliases.join(", ")}

`;
      }
      if (this.relatedTerms.length > 0) {
        content += `## \u76F8\u5173\u672F\u8BED

`;
        this.relatedTerms.forEach((relatedTerm) => {
          content += `- [[${relatedTerm.chineseName}]]
`;
        });
        content += "\n";
      }
      content += `## \u7B14\u8BB0

<!-- \u5728\u8FD9\u91CC\u6DFB\u52A0\u4F60\u7684\u5B66\u4E60\u7B14\u8BB0 -->

`;
      content += `---
`;
      content += `*\u6B64\u7B14\u8BB0\u7531\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u81EA\u52A8\u751F\u6210*
`;
      content += `*\u521B\u5EFA\u65F6\u95F4: ${this.formatDate(/* @__PURE__ */ new Date())}*
`;
      const file = await this.app.vault.create(fileName, content);
      await this.app.workspace.getLeaf().openFile(file);
      new import_obsidian10.Notice("\u672F\u8BED\u7B14\u8BB0\u521B\u5EFA\u6210\u529F");
      this.close();
    } catch (error) {
      console.error("\u521B\u5EFA\u672F\u8BED\u7B14\u8BB0\u5931\u8D25:", error);
      new import_obsidian10.Notice("\u521B\u5EFA\u672F\u8BED\u7B14\u8BB0\u5931\u8D25");
    }
  }
  /**
   * 格式化日期
   */
  formatDate(date) {
    return date.toLocaleString("zh-CN", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    });
  }
};

// src/ui/TermImportModal.ts
var import_obsidian11 = require("obsidian");
var TermImportModal = class extends import_obsidian11.Modal {
  constructor(app, databaseManager, onImportComplete) {
    super(app);
    this.importData = "";
    this.importMode = "json";
    this.previewTerms = [];
    this.databaseManager = databaseManager;
    this.onImportComplete = onImportComplete;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.textContent = "\u5BFC\u5165\u672F\u8BED";
    contentEl.empty();
    contentEl.addClass("term-import-modal");
    this.renderContent();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * 渲染内容
   */
  renderContent() {
    const { contentEl } = this;
    this.renderImportModeSelection(contentEl);
    this.renderDataInput(contentEl);
    this.renderPreview(contentEl);
    this.renderActions(contentEl);
  }
  /**
   * 渲染导入模式选择
   */
  renderImportModeSelection(container) {
    const modeSection = container.createDiv("import-mode-section");
    modeSection.createEl("h3", { text: "\u5BFC\u5165\u683C\u5F0F" });
    new import_obsidian11.Setting(modeSection).setName("\u9009\u62E9\u5BFC\u5165\u683C\u5F0F").setDesc("\u9009\u62E9\u8981\u5BFC\u5165\u7684\u6570\u636E\u683C\u5F0F").addDropdown((dropdown) => {
      dropdown.addOption("json", "JSON\u683C\u5F0F");
      dropdown.addOption("csv", "CSV\u683C\u5F0F");
      dropdown.addOption("text", "\u6587\u672C\u683C\u5F0F");
      dropdown.setValue(this.importMode);
      dropdown.onChange((value) => {
        this.importMode = value;
        this.updateInstructions();
      });
    });
    const instructionsEl = modeSection.createDiv("format-instructions");
    this.updateInstructions(instructionsEl);
  }
  /**
   * 更新格式说明
   */
  updateInstructions(container) {
    const instructionsEl = container || this.contentEl.querySelector(".format-instructions");
    if (!instructionsEl) return;
    instructionsEl.empty();
    switch (this.importMode) {
      case "json":
        instructionsEl.innerHTML = `
                    <h4>JSON\u683C\u5F0F\u8BF4\u660E</h4>
                    <p>\u8BF7\u8F93\u5165\u5305\u542B\u672F\u8BED\u6570\u7EC4\u7684JSON\u6570\u636E\uFF0C\u683C\u5F0F\u5982\u4E0B\uFF1A</p>
                    <pre><code>{
  "terms": [
    {
      "chineseName": "\u5BFC\u6570",
      "englishName": "Derivative",
      "category": "\u5FAE\u79EF\u5206",
      "latexCode": "\\\\frac{d}{dx}",
      "definition": "\u51FD\u6570\u5728\u67D0\u70B9\u7684\u53D8\u5316\u7387",
      "aliases": ["\u5FAE\u5206", "\u6C42\u5BFC"]
    }
  ]
}</code></pre>
                `;
        break;
      case "csv":
        instructionsEl.innerHTML = `
                    <h4>CSV\u683C\u5F0F\u8BF4\u660E</h4>
                    <p>\u8BF7\u8F93\u5165CSV\u683C\u5F0F\u7684\u6570\u636E\uFF0C\u7B2C\u4E00\u884C\u4E3A\u6807\u9898\u884C\uFF1A</p>
                    <pre><code>\u4E2D\u6587\u540D\u79F0,\u82F1\u6587\u540D\u79F0,\u5206\u7C7B,LaTeX\u4EE3\u7801,\u5B9A\u4E49,\u522B\u540D
\u5BFC\u6570,Derivative,\u5FAE\u79EF\u5206,\\\\frac{d}{dx},\u51FD\u6570\u5728\u67D0\u70B9\u7684\u53D8\u5316\u7387,"\u5FAE\u5206,\u6C42\u5BFC"
\u79EF\u5206,Integral,\u5FAE\u79EF\u5206,\\\\int,\u6C42\u9762\u79EF\u7684\u6570\u5B66\u8FD0\u7B97,"\u6C42\u79EF,\u79EF\u5206\u8FD0\u7B97"</code></pre>
                `;
        break;
      case "text":
        instructionsEl.innerHTML = `
                    <h4>\u6587\u672C\u683C\u5F0F\u8BF4\u660E</h4>
                    <p>\u6BCF\u884C\u4E00\u4E2A\u672F\u8BED\uFF0C\u683C\u5F0F\u4E3A\uFF1A\u4E2D\u6587\u540D\u79F0|\u82F1\u6587\u540D\u79F0|\u5206\u7C7B|LaTeX\u4EE3\u7801|\u5B9A\u4E49</p>
                    <pre><code>\u5BFC\u6570|Derivative|\u5FAE\u79EF\u5206|\\\\frac{d}{dx}|\u51FD\u6570\u5728\u67D0\u70B9\u7684\u53D8\u5316\u7387
\u79EF\u5206|Integral|\u5FAE\u79EF\u5206|\\\\int|\u6C42\u9762\u79EF\u7684\u6570\u5B66\u8FD0\u7B97</code></pre>
                `;
        break;
    }
  }
  /**
   * 渲染数据输入区域
   */
  renderDataInput(container) {
    const inputSection = container.createDiv("data-input-section");
    inputSection.createEl("h3", { text: "\u5BFC\u5165\u6570\u636E" });
    const fileInputContainer = inputSection.createDiv("file-input-container");
    const fileInput = fileInputContainer.createEl("input", {
      type: "file",
      attr: { accept: ".json,.csv,.txt" }
    });
    fileInput.addEventListener("change", (e) => {
      this.handleFileUpload(e);
    });
    const fileLabel = fileInputContainer.createEl("label");
    fileLabel.textContent = "\u9009\u62E9\u6587\u4EF6\u4E0A\u4F20";
    fileLabel.appendChild(fileInput);
    inputSection.createEl("div", { text: "\u6216\u8005", cls: "separator" });
    new import_obsidian11.Setting(inputSection).setName("\u76F4\u63A5\u8F93\u5165\u6570\u636E").setDesc("\u5728\u4E0B\u65B9\u6587\u672C\u6846\u4E2D\u76F4\u63A5\u8F93\u5165\u6216\u7C98\u8D34\u6570\u636E").addTextArea((text) => text.setPlaceholder("\u5728\u6B64\u8F93\u5165\u6216\u7C98\u8D34\u6570\u636E...").setValue(this.importData).onChange((value) => {
      this.importData = value;
      this.parseAndPreview();
    }));
  }
  /**
   * 处理文件上传
   */
  handleFileUpload(event) {
    var _a;
    const input = event.target;
    const file = (_a = input.files) == null ? void 0 : _a[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      var _a2;
      this.importData = (_a2 = e.target) == null ? void 0 : _a2.result;
      const textArea = this.contentEl.querySelector("textarea");
      if (textArea) {
        textArea.value = this.importData;
      }
      this.parseAndPreview();
    };
    reader.readAsText(file);
  }
  /**
   * 解析并预览数据
   */
  parseAndPreview() {
    if (!this.importData.trim()) {
      this.previewTerms = [];
      this.updatePreview();
      return;
    }
    try {
      switch (this.importMode) {
        case "json":
          this.previewTerms = this.parseJsonData(this.importData);
          break;
        case "csv":
          this.previewTerms = this.parseCsvData(this.importData);
          break;
        case "text":
          this.previewTerms = this.parseTextData(this.importData);
          break;
      }
      this.updatePreview();
    } catch (error) {
      console.error("\u89E3\u6790\u6570\u636E\u5931\u8D25:", error);
      new import_obsidian11.Notice("\u6570\u636E\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5\u8F93\u5165");
      this.previewTerms = [];
      this.updatePreview();
    }
  }
  /**
   * 解析JSON数据
   */
  parseJsonData(data) {
    const parsed = JSON.parse(data);
    const termsData = parsed.terms || parsed;
    if (!Array.isArray(termsData)) {
      throw new Error("JSON\u6570\u636E\u5FC5\u987B\u5305\u542B\u672F\u8BED\u6570\u7EC4");
    }
    return termsData.map((item, index) => this.createTermFromData(item, index));
  }
  /**
   * 解析CSV数据
   */
  parseCsvData(data) {
    const lines = data.trim().split("\n");
    if (lines.length < 2) {
      throw new Error("CSV\u6570\u636E\u81F3\u5C11\u9700\u8981\u6807\u9898\u884C\u548C\u4E00\u884C\u6570\u636E");
    }
    const dataLines = lines.slice(1);
    return dataLines.map((line, index) => {
      const columns = this.parseCsvLine(line);
      return this.createTermFromData({
        chineseName: columns[0],
        englishName: columns[1],
        category: columns[2],
        latexCode: columns[3],
        definition: columns[4],
        aliases: columns[5] ? columns[5].split(",").map((s) => s.trim()) : []
      }, index);
    });
  }
  /**
   * 解析文本数据
   */
  parseTextData(data) {
    const lines = data.trim().split("\n");
    return lines.map((line, index) => {
      var _a, _b, _c, _d, _e;
      const parts = line.split("|");
      return this.createTermFromData({
        chineseName: (_a = parts[0]) == null ? void 0 : _a.trim(),
        englishName: (_b = parts[1]) == null ? void 0 : _b.trim(),
        category: (_c = parts[2]) == null ? void 0 : _c.trim(),
        latexCode: (_d = parts[3]) == null ? void 0 : _d.trim(),
        definition: (_e = parts[4]) == null ? void 0 : _e.trim(),
        aliases: []
      }, index);
    });
  }
  /**
   * 解析CSV行（处理引号和逗号）
   */
  parseCsvLine(line) {
    const result = [];
    let current = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === "," && !inQuotes) {
        result.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  }
  /**
   * 从数据创建术语对象
   */
  createTermFromData(data, index) {
    var _a, _b, _c;
    const id = `imported_${Date.now()}_${index}`;
    const now = /* @__PURE__ */ new Date();
    if (!data.chineseName) {
      throw new Error(`\u7B2C${index + 1}\u884C\uFF1A\u4E2D\u6587\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A`);
    }
    let category = data.category;
    if (!Object.values(MathCategory).includes(category)) {
      const categoryMap = {
        "\u4EE3\u6570": "\u4EE3\u6570" /* ALGEBRA */,
        "\u5FAE\u79EF\u5206": "\u5FAE\u79EF\u5206" /* CALCULUS */,
        "\u51E0\u4F55": "\u51E0\u4F55" /* GEOMETRY */,
        "\u7EDF\u8BA1": "\u7EDF\u8BA1" /* STATISTICS */,
        "\u7EBF\u6027\u4EE3\u6570": "\u7EBF\u6027\u4EE3\u6570" /* LINEAR_ALGEBRA */,
        "\u79BB\u6563\u6570\u5B66": "\u79BB\u6563\u6570\u5B66" /* DISCRETE_MATH */,
        "\u6570\u8BBA": "\u6570\u8BBA" /* NUMBER_THEORY */,
        "\u62D3\u6251\u5B66": "\u62D3\u6251\u5B66" /* TOPOLOGY */,
        "\u6570\u5B66\u5206\u6790": "\u6570\u5B66\u5206\u6790" /* ANALYSIS */,
        "\u6982\u7387\u8BBA": "\u6982\u7387\u8BBA" /* PROBABILITY */
      };
      category = categoryMap[category] || "\u4EE3\u6570" /* ALGEBRA */;
    }
    return {
      id,
      chineseName: data.chineseName.trim(),
      englishName: ((_a = data.englishName) == null ? void 0 : _a.trim()) || void 0,
      category,
      latexCode: ((_b = data.latexCode) == null ? void 0 : _b.trim()) || "",
      definition: ((_c = data.definition) == null ? void 0 : _c.trim()) || void 0,
      aliases: Array.isArray(data.aliases) ? data.aliases : [],
      createdAt: now,
      updatedAt: now
    };
  }
  /**
   * 渲染预览区域
   */
  renderPreview(container) {
    const previewSection = container.createDiv("preview-section");
    previewSection.createEl("h3", { text: "\u9884\u89C8" });
    const previewContainer = previewSection.createDiv("preview-container");
    this.updatePreview(previewContainer);
  }
  /**
   * 更新预览
   */
  updatePreview(container) {
    const previewContainer = container || this.contentEl.querySelector(".preview-container");
    if (!previewContainer) return;
    previewContainer.empty();
    if (this.previewTerms.length === 0) {
      previewContainer.createEl("p", { text: "\u6682\u65E0\u9884\u89C8\u6570\u636E", cls: "no-preview" });
      return;
    }
    const statsEl = previewContainer.createDiv("preview-stats");
    statsEl.textContent = `\u5C06\u5BFC\u5165 ${this.previewTerms.length} \u4E2A\u672F\u8BED`;
    const previewList = previewContainer.createDiv("preview-list");
    const previewCount = Math.min(5, this.previewTerms.length);
    for (let i = 0; i < previewCount; i++) {
      const term = this.previewTerms[i];
      const termEl = previewList.createDiv("preview-term");
      termEl.createSpan({ text: term.chineseName, cls: "term-name" });
      if (term.englishName) {
        termEl.createSpan({ text: ` (${term.englishName})`, cls: "term-english" });
      }
      termEl.createSpan({ text: term.category, cls: "term-category" });
    }
    if (this.previewTerms.length > previewCount) {
      previewList.createEl("p", {
        text: `... \u8FD8\u6709 ${this.previewTerms.length - previewCount} \u4E2A\u672F\u8BED`,
        cls: "more-terms"
      });
    }
  }
  /**
   * 渲染操作按钮
   */
  renderActions(container) {
    const actionsContainer = container.createDiv("import-actions");
    const cancelBtn = actionsContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const importBtn = actionsContainer.createEl("button", { text: "\u5F00\u59CB\u5BFC\u5165" });
    importBtn.addClass("mod-cta");
    importBtn.addEventListener("click", async () => {
      await this.performImport();
    });
    importBtn.disabled = this.previewTerms.length === 0;
  }
  /**
   * 执行导入
   */
  async performImport() {
    if (this.previewTerms.length === 0) {
      new import_obsidian11.Notice("\u6CA1\u6709\u53EF\u5BFC\u5165\u7684\u6570\u636E");
      return;
    }
    try {
      let successCount = 0;
      let errorCount = 0;
      for (const term of this.previewTerms) {
        try {
          await this.databaseManager.saveTerm(term);
          successCount++;
        } catch (error) {
          console.error(`\u5BFC\u5165\u672F\u8BED\u5931\u8D25: ${term.chineseName}`, error);
          errorCount++;
        }
      }
      if (errorCount === 0) {
        new import_obsidian11.Notice(`\u6210\u529F\u5BFC\u5165 ${successCount} \u4E2A\u672F\u8BED`);
      } else {
        new import_obsidian11.Notice(`\u5BFC\u5165\u5B8C\u6210\uFF1A\u6210\u529F ${successCount} \u4E2A\uFF0C\u5931\u8D25 ${errorCount} \u4E2A`);
      }
      await this.onImportComplete();
      this.close();
    } catch (error) {
      console.error("\u5BFC\u5165\u8FC7\u7A0B\u4E2D\u51FA\u73B0\u9519\u8BEF:", error);
      new import_obsidian11.Notice("\u5BFC\u5165\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u6570\u636E\u683C\u5F0F");
    }
  }
};

// src/ui/TermManagementView.ts
var TERM_MANAGEMENT_VIEW_TYPE = "math-memory-graph-terms";
var TermManagementView = class extends import_obsidian12.ItemView {
  constructor(leaf, plugin) {
    var _a;
    super(leaf);
    this.terms = [];
    this.filteredTerms = [];
    this.currentCategory = "all";
    this.searchQuery = "";
    this.statistics = null;
    this.eventHandlers = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.databaseManager = (_a = plugin.getServiceManager()) == null ? void 0 : _a.getDatabaseManager();
  }
  getViewType() {
    return TERM_MANAGEMENT_VIEW_TYPE;
  }
  getDisplayText() {
    return "\u6570\u5B66\u672F\u8BED\u7BA1\u7406";
  }
  getIcon() {
    return "calculator";
  }
  async onOpen() {
    await this.loadTerms();
    this.render();
    this.registerEventListeners();
  }
  async onClose() {
    this.unregisterEventListeners();
  }
  /**
   * 加载术语数据
   */
  async loadTerms() {
    if (!this.databaseManager) {
      console.warn("TermManagementView: \u6570\u636E\u5E93\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      return;
    }
    try {
      this.terms = await this.databaseManager.getAllTerms();
      this.statistics = await this.databaseManager.getTermStatistics();
      this.applyFilters();
    } catch (error) {
      console.error("TermManagementView: \u52A0\u8F7D\u672F\u8BED\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u52A0\u8F7D\u672F\u8BED\u6570\u636E\u5931\u8D25");
    }
  }
  /**
   * 应用搜索和分类过滤
   */
  applyFilters() {
    let filtered = [...this.terms];
    if (this.currentCategory !== "all") {
      filtered = filtered.filter((term) => term.category === this.currentCategory);
    }
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase().trim();
      filtered = filtered.filter(
        (term) => {
          var _a, _b;
          return term.chineseName.toLowerCase().includes(query) || ((_a = term.englishName) == null ? void 0 : _a.toLowerCase().includes(query)) || term.aliases.some((alias) => alias.toLowerCase().includes(query)) || ((_b = term.definition) == null ? void 0 : _b.toLowerCase().includes(query));
        }
      );
    }
    filtered.sort((a, b) => a.chineseName.localeCompare(b.chineseName));
    this.filteredTerms = filtered;
  }
  /**
   * 渲染主界面
   */
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("math-term-management");
    this.renderHeader(container);
    this.renderStatistics(container);
    this.renderSearchAndFilter(container);
    this.renderTermList(container);
    this.renderActionButtons(container);
  }
  /**
   * 渲染头部区域
   */
  renderHeader(container) {
    const header = container.createDiv("term-management-header");
    const title = header.createEl("h2", { text: "\u6570\u5B66\u672F\u8BED\u7BA1\u7406" });
    title.addClass("term-management-title");
    const refreshBtn = header.createEl("button", { text: "\u5237\u65B0" });
    refreshBtn.addClass("mod-cta");
    refreshBtn.addEventListener("click", async () => {
      await this.loadTerms();
      this.render();
      new import_obsidian12.Notice("\u672F\u8BED\u6570\u636E\u5DF2\u5237\u65B0");
    });
  }
  /**
   * 渲染统计信息
   */
  renderStatistics(container) {
    if (!this.statistics) return;
    const statsContainer = container.createDiv("term-statistics");
    statsContainer.createEl("h3", { text: "\u7EDF\u8BA1\u4FE1\u606F" });
    const statsGrid = statsContainer.createDiv("stats-grid");
    const totalCard = statsGrid.createDiv("stat-card");
    totalCard.createEl("div", { text: this.statistics.totalTerms.toString(), cls: "stat-number" });
    totalCard.createEl("div", { text: "\u603B\u672F\u8BED\u6570", cls: "stat-label" });
    const categoryStats = statsGrid.createDiv("stat-card category-stats");
    categoryStats.createEl("div", { text: "\u5206\u7C7B\u5206\u5E03", cls: "stat-label" });
    const categoryList = categoryStats.createDiv("category-list");
    this.statistics.categoryCounts.forEach((count, category) => {
      const categoryItem = categoryList.createDiv("category-item");
      categoryItem.createSpan({ text: category, cls: "category-name" });
      categoryItem.createSpan({ text: count.toString(), cls: "category-count" });
    });
  }
  /**
   * 渲染搜索和过滤区域
   */
  renderSearchAndFilter(container) {
    const filterContainer = container.createDiv("term-filters");
    const searchContainer = filterContainer.createDiv("search-container");
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "\u641C\u7D22\u672F\u8BED...",
      value: this.searchQuery
    });
    searchInput.addClass("search-input");
    searchInput.addEventListener("input", (e) => {
      this.searchQuery = e.target.value;
      this.applyFilters();
      this.renderTermList(container.querySelector(".term-list-container"));
    });
    const categoryContainer = filterContainer.createDiv("category-filter");
    const categorySelect = categoryContainer.createEl("select");
    categorySelect.addClass("category-select");
    const allOption = categorySelect.createEl("option", { value: "all", text: "\u5168\u90E8\u5206\u7C7B" });
    if (this.currentCategory === "all") {
      allOption.selected = true;
    }
    Object.values(MathCategory).forEach((category) => {
      const option = categorySelect.createEl("option", { value: category, text: category });
      if (this.currentCategory === category) {
        option.selected = true;
      }
    });
    categorySelect.addEventListener("change", (e) => {
      const value = e.target.value;
      this.currentCategory = value === "all" ? "all" : value;
      this.applyFilters();
      this.renderTermList(container.querySelector(".term-list-container"));
    });
    const resultCount = filterContainer.createDiv("result-count");
    resultCount.textContent = `\u663E\u793A ${this.filteredTerms.length} / ${this.terms.length} \u4E2A\u672F\u8BED`;
  }
  /**
   * 渲染术语列表
   */
  renderTermList(container) {
    const existingContainer = container.querySelector(".term-list-container");
    if (existingContainer) {
      existingContainer.remove();
    }
    const listContainer = container.createDiv("term-list-container");
    if (this.filteredTerms.length === 0) {
      const emptyState = listContainer.createDiv("empty-state");
      emptyState.createEl("p", { text: "\u6CA1\u6709\u627E\u5230\u5339\u914D\u7684\u672F\u8BED" });
      return;
    }
    const termList = listContainer.createDiv("term-list");
    this.filteredTerms.forEach((term) => {
      const termItem = termList.createDiv("term-item");
      termItem.setAttribute("data-term-id", term.id);
      const termInfo = termItem.createDiv("term-info");
      const termName = termInfo.createDiv("term-name");
      termName.createSpan({ text: term.chineseName, cls: "chinese-name" });
      if (term.englishName) {
        termName.createSpan({ text: ` (${term.englishName})`, cls: "english-name" });
      }
      const termMeta = termInfo.createDiv("term-meta");
      termMeta.createSpan({ text: term.category, cls: "term-category" });
      if (term.latexCode) {
        termMeta.createSpan({ text: term.latexCode, cls: "latex-code" });
      }
      if (term.definition) {
        const definition = termInfo.createDiv("term-definition");
        definition.textContent = term.definition.length > 100 ? term.definition.substring(0, 100) + "..." : term.definition;
      }
      const termActions = termItem.createDiv("term-actions");
      const editBtn = termActions.createEl("button", { text: "\u7F16\u8F91" });
      editBtn.addClass("mod-cta");
      editBtn.addEventListener("click", () => this.editTerm(term));
      const deleteBtn = termActions.createEl("button", { text: "\u5220\u9664" });
      deleteBtn.addClass("mod-warning");
      deleteBtn.addEventListener("click", () => this.deleteTerm(term));
      const viewBtn = termActions.createEl("button", { text: "\u67E5\u770B" });
      viewBtn.addEventListener("click", () => this.viewTermDetails(term));
      termInfo.addEventListener("click", () => this.viewTermDetails(term));
      termInfo.addClass("clickable");
    });
  }
  /**
   * 渲染操作按钮
   */
  renderActionButtons(container) {
    const actionsContainer = container.createDiv("term-actions-container");
    const addBtn = actionsContainer.createEl("button", { text: "\u6DFB\u52A0\u65B0\u672F\u8BED" });
    addBtn.addClass("mod-cta");
    addBtn.addEventListener("click", () => this.addNewTerm());
    const importBtn = actionsContainer.createEl("button", { text: "\u5BFC\u5165\u672F\u8BED" });
    importBtn.addEventListener("click", () => this.importTerms());
    const exportBtn = actionsContainer.createEl("button", { text: "\u5BFC\u51FA\u672F\u8BED" });
    exportBtn.addEventListener("click", () => this.exportTerms());
  }
  /**
   * 添加新术语
   */
  addNewTerm() {
    new TermEditModal(this.app, null, async (term) => {
      if (this.databaseManager) {
        try {
          await this.databaseManager.saveTerm(term);
          await this.loadTerms();
          this.render();
          new import_obsidian12.Notice("\u672F\u8BED\u6DFB\u52A0\u6210\u529F");
        } catch (error) {
          console.error("\u6DFB\u52A0\u672F\u8BED\u5931\u8D25:", error);
          new import_obsidian12.Notice("\u6DFB\u52A0\u672F\u8BED\u5931\u8D25");
        }
      }
    }).open();
  }
  /**
   * 编辑术语
   */
  editTerm(term) {
    new TermEditModal(this.app, term, async (updatedTerm) => {
      if (this.databaseManager) {
        try {
          await this.databaseManager.updateTerm(updatedTerm);
          await this.loadTerms();
          this.render();
          new import_obsidian12.Notice("\u672F\u8BED\u66F4\u65B0\u6210\u529F");
        } catch (error) {
          console.error("\u66F4\u65B0\u672F\u8BED\u5931\u8D25:", error);
          new import_obsidian12.Notice("\u66F4\u65B0\u672F\u8BED\u5931\u8D25");
        }
      }
    }).open();
  }
  /**
   * 删除术语
   */
  async deleteTerm(term) {
    const confirmed = await this.showConfirmDialog(
      "\u786E\u8BA4\u5220\u9664",
      `\u786E\u5B9A\u8981\u5220\u9664\u672F\u8BED"${term.chineseName}"\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002`
    );
    if (confirmed && this.databaseManager) {
      try {
        await this.databaseManager.deleteTerm(term.id);
        await this.loadTerms();
        this.render();
        new import_obsidian12.Notice("\u672F\u8BED\u5220\u9664\u6210\u529F");
      } catch (error) {
        console.error("\u5220\u9664\u672F\u8BED\u5931\u8D25:", error);
        new import_obsidian12.Notice("\u5220\u9664\u672F\u8BED\u5931\u8D25");
      }
    }
  }
  /**
   * 查看术语详情
   */
  viewTermDetails(term) {
    new TermDetailModal(this.app, term, this.databaseManager).open();
  }
  /**
   * 导入术语
   */
  importTerms() {
    new TermImportModal(this.app, this.databaseManager, async () => {
      await this.loadTerms();
      this.render();
    }).open();
  }
  /**
   * 导出术语
   */
  async exportTerms() {
    try {
      const exportData = {
        terms: this.terms,
        exportDate: (/* @__PURE__ */ new Date()).toISOString(),
        version: "1.0.0"
      };
      const fileName = `math-terms-export-${Date.now()}.json`;
      const content = JSON.stringify(exportData, null, 2);
      const blob = new Blob([content], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      new import_obsidian12.Notice("\u672F\u8BED\u6570\u636E\u5BFC\u51FA\u6210\u529F");
    } catch (error) {
      console.error("\u5BFC\u51FA\u672F\u8BED\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u5BFC\u51FA\u672F\u8BED\u5931\u8D25");
    }
  }
  /**
   * 显示确认对话框
   */
  showConfirmDialog(title, message) {
    return new Promise((resolve) => {
      const modal = new import_obsidian12.Modal(this.app);
      modal.titleEl.textContent = title;
      const content = modal.contentEl;
      content.createEl("p", { text: message });
      const buttonContainer = content.createDiv("modal-button-container");
      const cancelBtn = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", { text: "\u786E\u8BA4" });
      confirmBtn.addClass("mod-warning");
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  /**
   * 注册事件监听器
   */
  registerEventListeners() {
    this.plugin.termManagementView = this;
  }
  /**
   * 注销事件监听器
   */
  unregisterEventListeners() {
    if (this.plugin.termManagementView === this) {
      this.plugin.termManagementView = null;
    }
  }
  /**
   * 聚焦搜索框（供外部调用）
   */
  focusSearch() {
    const searchInput = this.containerEl.querySelector(".search-input");
    if (searchInput) {
      searchInput.focus();
      searchInput.select();
    }
  }
  /**
   * 在图谱中查看术语（供外部调用）
   */
  viewTermInGraph(termId) {
    const term = this.terms.find((t) => t.id === termId);
    if (term) {
      new import_obsidian12.Notice(`\u5728\u56FE\u8C31\u4E2D\u67E5\u770B\u672F\u8BED: ${term.chineseName}`);
    }
  }
};

// src/core/ServiceManager.ts
var ServiceManager = class {
  constructor(app, plugin, settings) {
    this.services = /* @__PURE__ */ new Map();
    this.isInitialized = false;
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
  }
  /**
   * 初始化所有服务
   */
  async initialize() {
    console.log("ServiceManager: \u5F00\u59CB\u521D\u59CB\u5316\u670D\u52A1...");
    try {
      await this.initializeDataServices();
      await this.initializeRecognitionServices();
      await this.initializeLaTeXServices();
      await this.initializeUIServices();
      this.isInitialized = true;
      console.log("ServiceManager: \u6240\u6709\u670D\u52A1\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("ServiceManager: \u670D\u52A1\u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 销毁所有服务
   */
  async destroy() {
    console.log("ServiceManager: \u5F00\u59CB\u9500\u6BC1\u670D\u52A1...");
    try {
      await this.destroyUIServices();
      await this.destroyLaTeXServices();
      await this.destroyRecognitionServices();
      await this.destroyDataServices();
      this.services.clear();
      this.isInitialized = false;
      console.log("ServiceManager: \u6240\u6709\u670D\u52A1\u5DF2\u9500\u6BC1");
    } catch (error) {
      console.error("ServiceManager: \u670D\u52A1\u9500\u6BC1\u8FC7\u7A0B\u4E2D\u51FA\u73B0\u9519\u8BEF:", error);
    }
  }
  /**
   * 获取指定服务
   */
  getService(serviceName) {
    return this.services.get(serviceName) || null;
  }
  /**
   * 注册服务
   */
  registerService(serviceName, service) {
    this.services.set(serviceName, service);
    console.log(`ServiceManager: \u670D\u52A1 ${serviceName} \u5DF2\u6CE8\u518C`);
  }
  /**
   * 注销服务
   */
  unregisterService(serviceName) {
    if (this.services.has(serviceName)) {
      this.services.delete(serviceName);
      console.log(`ServiceManager: \u670D\u52A1 ${serviceName} \u5DF2\u6CE8\u9500`);
    }
  }
  /**
   * 检查服务是否已初始化
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * 获取数据库管理器
   */
  getDatabaseManager() {
    return this.getService("databaseManager");
  }
  /**
   * 更新设置并通知相关服务
   */
  async updateSettings(newSettings) {
    const oldSettings = this.settings;
    this.settings = newSettings;
    await this.notifySettingsChanged(oldSettings, newSettings);
  }
  /**
   * 初始化数据服务
   */
  async initializeDataServices() {
    console.log("ServiceManager: \u521D\u59CB\u5316\u6570\u636E\u670D\u52A1...");
    try {
      const migrationManager = new MigrationManager(this.app, this.plugin, "math-memory-graph");
      await migrationManager.migrate();
      this.registerService("migrationManager", migrationManager);
      const databaseManager = new DatabaseManager(this.app, this.plugin);
      await databaseManager.initialize();
      this.registerService("databaseManager", databaseManager);
      const dataAccessLayer = new DataAccessLayer(databaseManager);
      this.registerService("dataAccessLayer", dataAccessLayer);
      console.log("ServiceManager: \u6570\u636E\u670D\u52A1\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("ServiceManager: \u6570\u636E\u670D\u52A1\u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 初始化识别服务
   */
  async initializeRecognitionServices() {
    console.log("ServiceManager: \u521D\u59CB\u5316\u672F\u8BED\u8BC6\u522B\u670D\u52A1...");
    console.log("ServiceManager: \u672F\u8BED\u8BC6\u522B\u670D\u52A1\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 初始化LaTeX服务
   */
  async initializeLaTeXServices() {
    console.log("ServiceManager: \u521D\u59CB\u5316LaTeX\u670D\u52A1...");
    const renderer = this.settings.latexRenderer;
    console.log(`ServiceManager: \u4F7F\u7528 ${renderer} \u4F5C\u4E3ALaTeX\u6E32\u67D3\u5668`);
    console.log("ServiceManager: LaTeX\u670D\u52A1\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 初始化UI服务
   */
  async initializeUIServices() {
    console.log("ServiceManager: \u521D\u59CB\u5316UI\u670D\u52A1...");
    try {
      this.plugin.registerView(
        TERM_MANAGEMENT_VIEW_TYPE,
        (leaf) => new TermManagementView(leaf, this.plugin)
      );
      console.log("ServiceManager: \u672F\u8BED\u7BA1\u7406\u89C6\u56FE\u5DF2\u6CE8\u518C");
      console.log("ServiceManager: UI\u670D\u52A1\u521D\u59CB\u5316\u5B8C\u6210");
    } catch (error) {
      console.error("ServiceManager: UI\u670D\u52A1\u521D\u59CB\u5316\u5931\u8D25:", error);
      throw error;
    }
  }
  /**
   * 销毁数据服务
   */
  async destroyDataServices() {
    console.log("ServiceManager: \u9500\u6BC1\u6570\u636E\u670D\u52A1...");
  }
  /**
   * 销毁识别服务
   */
  async destroyRecognitionServices() {
    console.log("ServiceManager: \u9500\u6BC1\u672F\u8BED\u8BC6\u522B\u670D\u52A1...");
  }
  /**
   * 销毁LaTeX服务
   */
  async destroyLaTeXServices() {
    console.log("ServiceManager: \u9500\u6BC1LaTeX\u670D\u52A1...");
  }
  /**
   * 销毁UI服务
   */
  async destroyUIServices() {
    console.log("ServiceManager: \u9500\u6BC1UI\u670D\u52A1...");
  }
  /**
   * 通知设置变更
   */
  async notifySettingsChanged(oldSettings, newSettings) {
    console.log("ServiceManager: \u901A\u77E5\u8BBE\u7F6E\u53D8\u66F4...");
    if (oldSettings.enableAutoRecognition !== newSettings.enableAutoRecognition) {
      console.log("ServiceManager: \u81EA\u52A8\u8BC6\u522B\u8BBE\u7F6E\u5DF2\u53D8\u66F4");
    }
    if (oldSettings.latexRenderer !== newSettings.latexRenderer) {
      console.log("ServiceManager: LaTeX\u6E32\u67D3\u5668\u8BBE\u7F6E\u5DF2\u53D8\u66F4");
    }
    if (oldSettings.graphLayout !== newSettings.graphLayout) {
      console.log("ServiceManager: \u56FE\u8C31\u5E03\u5C40\u8BBE\u7F6E\u5DF2\u53D8\u66F4");
    }
  }
};

// src/core/CommandManager.ts
var import_obsidian13 = require("obsidian");
var CommandManager = class {
  constructor(app, plugin, settings) {
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
  }
  /**
   * 注册所有命令
   */
  registerCommands() {
    console.log("CommandManager: \u6CE8\u518C\u63D2\u4EF6\u547D\u4EE4...");
    this.registerMathInputCommands();
    this.registerGraphCommands();
    this.registerRecognitionCommands();
    this.registerLaTeXCommands();
    this.registerTermManagementCommands();
    this.registerUtilityCommands();
    console.log("CommandManager: \u6240\u6709\u547D\u4EE4\u6CE8\u518C\u5B8C\u6210");
  }
  /**
   * 更新设置引用
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
  }
  /**
   * 注册数学输入相关命令
   */
  registerMathInputCommands() {
    this.plugin.addCommand({
      id: "toggle-math-input",
      name: "\u5207\u6362\u6570\u5B66\u8F93\u5165\u6A21\u5F0F",
      icon: "calculator",
      callback: () => {
        this.toggleMathInput();
      },
      hotkeys: [
        {
          modifiers: ["Ctrl"],
          key: "m"
        }
      ]
    });
    this.plugin.addCommand({
      id: "insert-math-template",
      name: "\u63D2\u5165\u6570\u5B66\u516C\u5F0F\u6A21\u677F",
      icon: "formula",
      editorCallback: (editor) => {
        this.insertMathTemplate(editor);
      }
    });
    this.plugin.addCommand({
      id: "smart-math-completion",
      name: "\u667A\u80FD\u6570\u5B66\u8865\u5168",
      icon: "zap",
      editorCallback: (editor) => {
        this.triggerSmartCompletion(editor);
      }
    });
  }
  /**
   * 注册图谱相关命令
   */
  registerGraphCommands() {
    this.plugin.addCommand({
      id: "open-graph-view",
      name: "\u6253\u5F00\u6570\u5B66\u77E5\u8BC6\u56FE\u8C31",
      icon: "git-branch",
      callback: () => {
        this.openGraphView();
      },
      hotkeys: [
        {
          modifiers: ["Ctrl", "Shift"],
          key: "g"
        }
      ]
    });
    this.plugin.addCommand({
      id: "focus-current-term",
      name: "\u5728\u56FE\u8C31\u4E2D\u805A\u7126\u5F53\u524D\u672F\u8BED",
      icon: "target",
      editorCallback: (editor) => {
        this.focusCurrentTerm(editor);
      }
    });
    this.plugin.addCommand({
      id: "export-graph",
      name: "\u5BFC\u51FA\u6570\u5B66\u77E5\u8BC6\u56FE\u8C31",
      icon: "download",
      callback: () => {
        this.exportGraph();
      }
    });
  }
  /**
   * 注册术语识别相关命令
   */
  registerRecognitionCommands() {
    this.plugin.addCommand({
      id: "recognize-terms",
      name: "\u8BC6\u522B\u6570\u5B66\u672F\u8BED",
      icon: "search",
      callback: () => {
        this.recognizeTermsInCurrentNote();
      },
      hotkeys: [
        {
          modifiers: ["Ctrl", "Shift"],
          key: "r"
        }
      ]
    });
    this.plugin.addCommand({
      id: "add-custom-term",
      name: "\u6DFB\u52A0\u81EA\u5B9A\u4E49\u672F\u8BED",
      icon: "plus",
      editorCallback: (editor) => {
        this.addCustomTerm(editor);
      }
    });
    this.plugin.addCommand({
      id: "batch-recognize-all",
      name: "\u6279\u91CF\u8BC6\u522B\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u672F\u8BED",
      icon: "layers",
      callback: () => {
        this.batchRecognizeAllNotes();
      }
    });
  }
  /**
   * 注册LaTeX相关命令
   */
  registerLaTeXCommands() {
    this.plugin.addCommand({
      id: "convert-to-latex",
      name: "\u8F6C\u6362\u4E3ALaTeX\u4EE3\u7801",
      icon: "code",
      editorCallback: (editor) => {
        this.convertSelectionToLaTeX(editor);
      }
    });
    this.plugin.addCommand({
      id: "preview-latex",
      name: "\u9884\u89C8LaTeX\u6E32\u67D3",
      icon: "eye",
      editorCallback: (editor) => {
        this.previewLaTeX(editor);
      }
    });
    this.plugin.addCommand({
      id: "copy-latex-code",
      name: "\u590D\u5236LaTeX\u4EE3\u7801",
      icon: "copy",
      editorCallback: (editor) => {
        this.copyLaTeXCode(editor);
      }
    });
  }
  /**
   * 注册术语管理命令
   */
  registerTermManagementCommands() {
    this.plugin.addCommand({
      id: "open-term-management",
      name: "\u6253\u5F00\u672F\u8BED\u7BA1\u7406",
      icon: "list",
      callback: () => {
        this.openTermManagement();
      }
    });
    this.plugin.addCommand({
      id: "add-new-term",
      name: "\u6DFB\u52A0\u65B0\u672F\u8BED",
      icon: "plus-circle",
      callback: () => {
        this.addNewTerm();
      }
    });
    this.plugin.addCommand({
      id: "search-terms",
      name: "\u641C\u7D22\u672F\u8BED",
      icon: "search",
      callback: () => {
        this.searchTerms();
      }
    });
  }
  /**
   * 注册工具命令
   */
  registerUtilityCommands() {
    this.plugin.addCommand({
      id: "show-term-stats",
      name: "\u663E\u793A\u672F\u8BED\u7EDF\u8BA1",
      icon: "bar-chart",
      callback: () => {
        this.showTermStatistics();
      }
    });
    this.plugin.addCommand({
      id: "cleanup-database",
      name: "\u6E05\u7406\u6570\u636E\u5E93",
      icon: "trash",
      callback: () => {
        this.cleanupDatabase();
      }
    });
    this.plugin.addCommand({
      id: "export-data",
      name: "\u5BFC\u51FA\u672F\u8BED\u6570\u636E",
      icon: "package",
      callback: () => {
        this.exportData();
      }
    });
    this.plugin.addCommand({
      id: "import-data",
      name: "\u5BFC\u5165\u672F\u8BED\u6570\u636E",
      icon: "upload",
      callback: () => {
        this.importData();
      }
    });
  }
  // ==================== 命令实现方法 ====================
  toggleMathInput() {
    if (this.settings.enableMathInput) {
      new import_obsidian13.Notice("\u6570\u5B66\u8F93\u5165\u6A21\u5F0F\u5DF2\u6FC0\u6D3B");
      console.log("CommandManager: \u6FC0\u6D3B\u6570\u5B66\u8F93\u5165\u6A21\u5F0F");
    } else {
      new import_obsidian13.Notice("\u6570\u5B66\u8F93\u5165\u6A21\u5F0F\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
    }
  }
  insertMathTemplate(editor) {
    const cursor = editor.getCursor();
    const templates = [
      "$$\\begin{align}\n\n\\end{align}$$",
      "$\\frac{}{}$",
      "$\\sum_{i=1}^{n}$",
      "$\\int_{a}^{b}$"
    ];
    editor.replaceRange(templates[0], cursor);
    new import_obsidian13.Notice("\u5DF2\u63D2\u5165\u6570\u5B66\u516C\u5F0F\u6A21\u677F");
  }
  triggerSmartCompletion(editor) {
    const cursor = editor.getCursor();
    const currentLine = editor.getLine(cursor.line);
    console.log("CommandManager: \u89E6\u53D1\u667A\u80FD\u8865\u5168\uFF0C\u5F53\u524D\u884C:", currentLine);
    new import_obsidian13.Notice("\u667A\u80FD\u6570\u5B66\u8865\u5168\u529F\u80FD\u5C06\u5728\u540E\u7EED\u7248\u672C\u4E2D\u5B9E\u73B0");
  }
  openGraphView() {
    if (this.settings.enableGraphView) {
      new import_obsidian13.Notice("\u6B63\u5728\u6253\u5F00\u6570\u5B66\u77E5\u8BC6\u56FE\u8C31...");
      console.log("CommandManager: \u6253\u5F00\u56FE\u8C31\u89C6\u56FE");
    } else {
      new import_obsidian13.Notice("\u77E5\u8BC6\u56FE\u8C31\u529F\u80FD\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
    }
  }
  focusCurrentTerm(editor) {
    const selection = editor.getSelection();
    if (selection) {
      console.log("CommandManager: \u805A\u7126\u672F\u8BED:", selection);
      new import_obsidian13.Notice(`\u6B63\u5728\u56FE\u8C31\u4E2D\u805A\u7126\u672F\u8BED: ${selection}`);
    } else {
      new import_obsidian13.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u672F\u8BED");
    }
  }
  exportGraph() {
    new import_obsidian13.Notice("\u6B63\u5728\u5BFC\u51FA\u77E5\u8BC6\u56FE\u8C31...");
    console.log("CommandManager: \u5BFC\u51FA\u56FE\u8C31");
  }
  async recognizeTermsInCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian13.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u6587\u4EF6");
      return;
    }
    if (!this.settings.enableAutoRecognition) {
      new import_obsidian13.Notice("\u672F\u8BED\u8BC6\u522B\u529F\u80FD\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
      return;
    }
    try {
      new import_obsidian13.Notice("\u6B63\u5728\u8BC6\u522B\u6570\u5B66\u672F\u8BED...");
      console.log("CommandManager: \u8BC6\u522B\u672F\u8BED\uFF0C\u6587\u4EF6:", activeFile.path);
      const mainPlugin = this.plugin;
      const mainController = mainPlugin.mainController;
      if (mainController && mainController.getTermRecognitionEngine) {
        await mainController.recognizeTermsInCurrentNote();
        new import_obsidian13.Notice("\u672F\u8BED\u8BC6\u522B\u5B8C\u6210");
      } else {
        new import_obsidian13.Notice("\u672F\u8BED\u8BC6\u522B\u5F15\u64CE\u672A\u521D\u59CB\u5316");
      }
    } catch (error) {
      console.error("CommandManager: \u672F\u8BED\u8BC6\u522B\u5931\u8D25:", error);
      new import_obsidian13.Notice("\u672F\u8BED\u8BC6\u522B\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u63A7\u5236\u53F0\u9519\u8BEF\u4FE1\u606F");
    }
  }
  addCustomTerm(editor) {
    const selection = editor.getSelection();
    if (selection) {
      console.log("CommandManager: \u6DFB\u52A0\u81EA\u5B9A\u4E49\u672F\u8BED:", selection);
      new import_obsidian13.Notice(`\u6B63\u5728\u6DFB\u52A0\u81EA\u5B9A\u4E49\u672F\u8BED: ${selection}`);
    } else {
      new import_obsidian13.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u6DFB\u52A0\u7684\u672F\u8BED\u6587\u672C");
    }
  }
  batchRecognizeAllNotes() {
    new import_obsidian13.Notice("\u6B63\u5728\u6279\u91CF\u8BC6\u522B\u6240\u6709\u7B14\u8BB0\u4E2D\u7684\u672F\u8BED...");
    console.log("CommandManager: \u6279\u91CF\u8BC6\u522B\u6240\u6709\u7B14\u8BB0");
  }
  convertSelectionToLaTeX(editor) {
    const selection = editor.getSelection();
    if (selection) {
      console.log("CommandManager: \u8F6C\u6362\u4E3ALaTeX:", selection);
      new import_obsidian13.Notice(`\u6B63\u5728\u8F6C\u6362\u4E3ALaTeX: ${selection}`);
    } else {
      new import_obsidian13.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u8F6C\u6362\u7684\u6587\u672C");
    }
  }
  previewLaTeX(editor) {
    const selection = editor.getSelection();
    if (selection) {
      console.log("CommandManager: \u9884\u89C8LaTeX:", selection);
      new import_obsidian13.Notice("\u6B63\u5728\u9884\u89C8LaTeX\u6E32\u67D3...");
    } else {
      new import_obsidian13.Notice("\u8BF7\u5148\u9009\u62E9LaTeX\u4EE3\u7801");
    }
  }
  copyLaTeXCode(editor) {
    const selection = editor.getSelection();
    if (selection) {
      navigator.clipboard.writeText(selection).then(() => {
        new import_obsidian13.Notice("LaTeX\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F");
      }).catch(() => {
        new import_obsidian13.Notice("\u590D\u5236\u5931\u8D25");
      });
    } else {
      new import_obsidian13.Notice("\u8BF7\u5148\u9009\u62E9LaTeX\u4EE3\u7801");
    }
  }
  showTermStatistics() {
    new import_obsidian13.Notice("\u6B63\u5728\u751F\u6210\u672F\u8BED\u7EDF\u8BA1...");
    console.log("CommandManager: \u663E\u793A\u672F\u8BED\u7EDF\u8BA1");
  }
  cleanupDatabase() {
    new import_obsidian13.Notice("\u6B63\u5728\u6E05\u7406\u6570\u636E\u5E93...");
    console.log("CommandManager: \u6E05\u7406\u6570\u636E\u5E93");
  }
  exportData() {
    new import_obsidian13.Notice("\u6B63\u5728\u5BFC\u51FA\u672F\u8BED\u6570\u636E...");
    console.log("CommandManager: \u5BFC\u51FA\u6570\u636E");
  }
  importData() {
    new import_obsidian13.Notice("\u6B63\u5728\u5BFC\u5165\u672F\u8BED\u6570\u636E...");
    console.log("CommandManager: \u5BFC\u5165\u6570\u636E");
  }
  // ==================== 术语管理命令实现 ====================
  async openTermManagement() {
    try {
      const existingLeaf = this.app.workspace.getLeavesOfType(TERM_MANAGEMENT_VIEW_TYPE)[0];
      if (existingLeaf) {
        this.app.workspace.revealLeaf(existingLeaf);
      } else {
        const leaf = this.app.workspace.getRightLeaf(false);
        await leaf.setViewState({
          type: TERM_MANAGEMENT_VIEW_TYPE,
          active: true
        });
        this.app.workspace.rightSplit.expand();
      }
      new import_obsidian13.Notice("\u672F\u8BED\u7BA1\u7406\u754C\u9762\u5DF2\u6253\u5F00");
    } catch (error) {
      console.error("CommandManager: \u6253\u5F00\u672F\u8BED\u7BA1\u7406\u5931\u8D25:", error);
      new import_obsidian13.Notice("\u6253\u5F00\u672F\u8BED\u7BA1\u7406\u5931\u8D25");
    }
  }
  addNewTerm() {
    const termManagementView = this.plugin.termManagementView;
    if (termManagementView) {
      termManagementView.addNewTerm();
    } else {
      this.openTermManagement().then(() => {
        const view = this.plugin.termManagementView;
        if (view) {
          setTimeout(() => view.addNewTerm(), 100);
        }
      });
    }
  }
  searchTerms() {
    this.openTermManagement().then(() => {
      const termManagementView = this.plugin.termManagementView;
      if (termManagementView) {
        setTimeout(() => termManagementView.focusSearch(), 100);
      }
    });
  }
};

// src/core/EventManager.ts
var EventManager = class {
  constructor(app, plugin, settings) {
    this.eventRefs = [];
    this.debounceTimers = /* @__PURE__ */ new Map();
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
  }
  /**
   * 注册所有事件监听器
   */
  registerEventHandlers() {
    console.log("EventManager: \u6CE8\u518C\u4E8B\u4EF6\u76D1\u542C\u5668...");
    this.registerEditorEvents();
    this.registerFileSystemEvents();
    this.registerWorkspaceEvents();
    this.registerMarkdownEvents();
    console.log("EventManager: \u6240\u6709\u4E8B\u4EF6\u76D1\u542C\u5668\u6CE8\u518C\u5B8C\u6210");
  }
  /**
   * 注销所有事件监听器
   */
  unregisterEventHandlers() {
    console.log("EventManager: \u6CE8\u9500\u4E8B\u4EF6\u76D1\u542C\u5668...");
    this.eventRefs.forEach((ref) => {
      this.app.workspace.offref(ref);
    });
    this.eventRefs = [];
    this.debounceTimers.forEach((timer) => {
      clearTimeout(timer);
    });
    this.debounceTimers.clear();
    console.log("EventManager: \u6240\u6709\u4E8B\u4EF6\u76D1\u542C\u5668\u5DF2\u6CE8\u9500");
  }
  /**
   * 更新设置引用
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
  }
  /**
   * 注册编辑器事件
   */
  registerEditorEvents() {
    const editorChangeRef = this.app.workspace.on("editor-change", (editor, view) => {
      if (this.settings.enableAutoRecognition) {
        this.debounceTermRecognition("editor-change", () => {
          this.handleEditorChange(editor, view);
        });
      }
    });
    this.eventRefs.push(editorChangeRef);
    const selectionChangeRef = this.app.workspace.on("editor-change", (editor) => {
      this.handleSelectionChange(editor);
    });
    this.eventRefs.push(selectionChangeRef);
    console.log("EventManager: \u7F16\u8F91\u5668\u4E8B\u4EF6\u5DF2\u6CE8\u518C");
  }
  /**
   * 注册文件系统事件
   */
  registerFileSystemEvents() {
    const fileOpenRef = this.app.workspace.on("file-open", (file) => {
      if (file && this.settings.enableAutoRecognition) {
        this.handleFileOpen(file);
      }
    });
    this.eventRefs.push(fileOpenRef);
    const fileRenameRef = this.app.vault.on("rename", (file, oldPath) => {
      this.handleFileRename(file, oldPath);
    });
    this.eventRefs.push(fileRenameRef);
    const fileDeleteRef = this.app.vault.on("delete", (file) => {
      this.handleFileDelete(file);
    });
    this.eventRefs.push(fileDeleteRef);
    console.log("EventManager: \u6587\u4EF6\u7CFB\u7EDF\u4E8B\u4EF6\u5DF2\u6CE8\u518C");
  }
  /**
   * 注册工作区事件
   */
  registerWorkspaceEvents() {
    const activeLeafChangeRef = this.app.workspace.on("active-leaf-change", (leaf) => {
      this.handleActiveLeafChange(leaf);
    });
    this.eventRefs.push(activeLeafChangeRef);
    const layoutChangeRef = this.app.workspace.on("layout-change", () => {
      this.handleLayoutChange();
    });
    this.eventRefs.push(layoutChangeRef);
    console.log("EventManager: \u5DE5\u4F5C\u533A\u4E8B\u4EF6\u5DF2\u6CE8\u518C");
  }
  /**
   * 注册Markdown处理事件
   */
  registerMarkdownEvents() {
    this.plugin.registerMarkdownPostProcessor((element, context) => {
      this.handleMarkdownPostProcess(element, context);
    });
    console.log("EventManager: Markdown\u4E8B\u4EF6\u5DF2\u6CE8\u518C");
  }
  // ==================== 事件处理方法 ====================
  /**
   * 处理编辑器内容变化
   */
  handleEditorChange(editor, view) {
    console.log("EventManager: \u5904\u7406\u7F16\u8F91\u5668\u53D8\u5316");
    const content = editor.getValue();
    const cursor = editor.getCursor();
    if (content.length > 0 && this.shouldTriggerRecognition(content, cursor)) {
      this.triggerTermRecognition(editor, content);
    }
  }
  /**
   * 处理选择变化
   */
  handleSelectionChange(editor) {
    const selection = editor.getSelection();
    if (selection && selection.length > 0) {
      console.log("EventManager: \u9009\u62E9\u53D8\u5316:", selection);
    }
  }
  /**
   * 处理文件打开
   */
  handleFileOpen(file) {
    console.log("EventManager: \u6587\u4EF6\u6253\u5F00:", file.path);
    if (file.extension === "md") {
      this.debounceTermRecognition("file-open", () => {
        this.processFileForTerms(file);
      });
    }
  }
  /**
   * 处理文件重命名
   */
  handleFileRename(file, oldPath) {
    console.log("EventManager: \u6587\u4EF6\u91CD\u547D\u540D:", oldPath, "->", file.path);
  }
  /**
   * 处理文件删除
   */
  handleFileDelete(file) {
    console.log("EventManager: \u6587\u4EF6\u5220\u9664:", file.path);
  }
  /**
   * 处理活动叶子变化
   */
  handleActiveLeafChange(leaf) {
    console.log("EventManager: \u6D3B\u52A8\u53F6\u5B50\u53D8\u5316");
  }
  /**
   * 处理布局变化
   */
  handleLayoutChange() {
    console.log("EventManager: \u5E03\u5C40\u53D8\u5316");
  }
  /**
   * 处理Markdown后处理
   */
  handleMarkdownPostProcess(element, context) {
    console.log("EventManager: Markdown\u540E\u5904\u7406\uFF0C\u6E90\u8DEF\u5F84:", context.sourcePath);
    this.processMathElements(element, context);
    this.processTermHighlighting(element, context);
  }
  // ==================== 辅助方法 ====================
  /**
   * 防抖处理
   */
  debounceTermRecognition(key, callback, delay = 500) {
    if (this.debounceTimers.has(key)) {
      clearTimeout(this.debounceTimers.get(key));
    }
    const timer = setTimeout(() => {
      callback();
      this.debounceTimers.delete(key);
    }, delay);
    this.debounceTimers.set(key, timer);
  }
  /**
   * 判断是否应该触发识别
   */
  shouldTriggerRecognition(content, cursor) {
    if (content.length < 10) {
      return false;
    }
    const currentLine = content.split("\n")[cursor.line];
    if (currentLine && (currentLine.includes("```") || currentLine.includes("`"))) {
      return false;
    }
    return true;
  }
  /**
   * 触发术语识别
   */
  triggerTermRecognition(editor, content) {
    console.log("EventManager: \u89E6\u53D1\u672F\u8BED\u8BC6\u522B\uFF0C\u5185\u5BB9\u957F\u5EA6:", content.length);
  }
  /**
   * 处理文件中的术语
   */
  processFileForTerms(file) {
    console.log("EventManager: \u5904\u7406\u6587\u4EF6\u672F\u8BED:", file.path);
  }
  /**
   * 处理数学元素
   */
  processMathElements(element, context) {
    const mathElements = element.querySelectorAll(".math, .math-block");
    mathElements.forEach((mathEl) => {
      console.log("EventManager: \u5904\u7406\u6570\u5B66\u5143\u7D20:", mathEl.textContent);
    });
  }
  /**
   * 处理术语高亮
   */
  processTermHighlighting(element, context) {
    console.log("EventManager: \u5904\u7406\u672F\u8BED\u9AD8\u4EAE");
  }
};

// main.ts
var MathMemoryGraphPlugin = class extends import_obsidian14.Plugin {
  async onload() {
    console.log("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u52A0\u8F7D\u4E2D...");
    try {
      await this.loadSettings();
      const validation = SettingsValidator.validate(this.settings);
      if (!validation.isValid) {
        console.warn("\u8BBE\u7F6E\u9A8C\u8BC1\u5931\u8D25:", validation.errors);
        new import_obsidian14.Notice("\u63D2\u4EF6\u8BBE\u7F6E\u5B58\u5728\u95EE\u9898\uFF0C\u8BF7\u68C0\u67E5\u8BBE\u7F6E\u9762\u677F");
      }
      this.loadStyles();
      await this.initializeManagers();
      this.addSettingTab(new MathMemoryGraphSettingTab(this.app, this));
      new import_obsidian14.Notice("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u5DF2\u52A0\u8F7D");
      console.log("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u52A0\u8F7D\u5B8C\u6210");
    } catch (error) {
      console.error("\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25:", error);
      new import_obsidian14.Notice("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u63A7\u5236\u53F0\u9519\u8BEF\u4FE1\u606F");
    }
  }
  async onunload() {
    console.log("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u5378\u8F7D\u4E2D...");
    try {
      await this.cleanupManagers();
      console.log("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u5DF2\u5378\u8F7D");
    } catch (error) {
      console.error("\u63D2\u4EF6\u5378\u8F7D\u8FC7\u7A0B\u4E2D\u51FA\u73B0\u9519\u8BEF:", error);
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = SettingsValidator.merge(loadedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.serviceManager) {
      await this.serviceManager.updateSettings(this.settings);
    }
    if (this.commandManager) {
      this.commandManager.updateSettings(this.settings);
    }
    if (this.eventManager) {
      this.eventManager.updateSettings(this.settings);
    }
    if (this.mainController) {
      this.mainController.updateSettings(this.settings);
    }
  }
  /**
   * 初始化所有管理器
   */
  async initializeManagers() {
    console.log("\u521D\u59CB\u5316\u6838\u5FC3\u7BA1\u7406\u5668...");
    this.mainController = new MainController(this.app, this, this.settings);
    await this.mainController.onload();
    this.serviceManager = new ServiceManager(this.app, this, this.settings);
    await this.serviceManager.initialize();
    this.commandManager = new CommandManager(this.app, this, this.settings);
    this.commandManager.registerCommands();
    this.eventManager = new EventManager(this.app, this, this.settings);
    this.eventManager.registerEventHandlers();
    console.log("\u6240\u6709\u6838\u5FC3\u7BA1\u7406\u5668\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 清理所有管理器
   */
  async cleanupManagers() {
    console.log("\u6E05\u7406\u6838\u5FC3\u7BA1\u7406\u5668...");
    if (this.eventManager) {
      this.eventManager.unregisterEventHandlers();
    }
    if (this.serviceManager) {
      await this.serviceManager.destroy();
    }
    if (this.mainController) {
      this.mainController.onunload();
    }
    console.log("\u6240\u6709\u6838\u5FC3\u7BA1\u7406\u5668\u5DF2\u6E05\u7406");
  }
  /**
   * 获取服务管理器（供其他模块使用）
   */
  getServiceManager() {
    return this.serviceManager;
  }
  /**
   * 检查插件是否已准备就绪
   */
  isReady() {
    var _a, _b;
    return ((_a = this.mainController) == null ? void 0 : _a.isReady()) && ((_b = this.serviceManager) == null ? void 0 : _b.isReady());
  }
  /**
   * 加载插件样式
   */
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "math-memory-graph-styles";
    styleEl.textContent = `
			/* \u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u6837\u5F0F */
			.math-term-management {
				padding: 16px;
				height: 100%;
				overflow-y: auto;
			}
			
			.term-management-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 16px;
				padding-bottom: 12px;
				border-bottom: 1px solid var(--background-modifier-border);
			}
			
			.term-management-title {
				margin: 0;
				color: var(--text-normal);
			}
			
			.term-item {
				display: flex;
				justify-content: space-between;
				align-items: flex-start;
				padding: 12px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				transition: all 0.2s ease;
				margin-bottom: 8px;
			}
			
			.term-item:hover {
				background: var(--background-secondary);
				border-color: var(--text-accent);
			}
			
			.term-info {
				flex: 1;
				cursor: pointer;
			}
			
			.chinese-name {
				font-weight: bold;
				color: var(--text-normal);
				font-size: 16px;
			}
			
			.english-name {
				color: var(--text-muted);
				font-style: italic;
			}
			
			.term-category {
				background: var(--text-accent);
				color: var(--text-on-accent);
				padding: 2px 8px;
				border-radius: 12px;
				font-size: 11px;
				font-weight: bold;
				text-transform: uppercase;
			}
			
			.term-actions button {
				padding: 4px 8px;
				font-size: 12px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-primary);
				color: var(--text-normal);
				cursor: pointer;
				transition: all 0.2s ease;
				margin-left: 6px;
			}
			
			.term-actions button:hover {
				background: var(--background-secondary);
			}
			
			.term-actions button.mod-cta {
				background: var(--text-accent);
				color: var(--text-on-accent);
				border-color: var(--text-accent);
			}
			
			.term-actions button.mod-warning {
				background: var(--text-error);
				color: var(--text-on-accent);
				border-color: var(--text-error);
			}
		`;
    document.head.appendChild(styleEl);
    console.log("\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6\u6837\u5F0F\u5DF2\u52A0\u8F7D");
  }
};
var MathMemoryGraphSettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31 - \u8BBE\u7F6E" });
    this.addBasicSettings(containerEl);
    this.addRecognitionSettings(containerEl);
    this.addGraphSettings(containerEl);
    this.addLaTeXSettings(containerEl);
    this.addAdvancedSettings(containerEl);
    this.addShortcutSettings(containerEl);
    this.addAboutSection(containerEl);
  }
  addBasicSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u57FA\u672C\u529F\u80FD" });
    new import_obsidian14.Setting(containerEl).setName("\u81EA\u52A8\u672F\u8BED\u8BC6\u522B").setDesc("\u5728\u7F16\u8F91\u65F6\u81EA\u52A8\u8BC6\u522B\u6570\u5B66\u672F\u8BED").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoRecognition).onChange(async (value) => {
      this.plugin.settings.enableAutoRecognition = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u77E5\u8BC6\u56FE\u8C31\u89C6\u56FE").setDesc("\u542F\u7528\u6570\u5B66\u77E5\u8BC6\u56FE\u8C31\u53EF\u89C6\u5316").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableGraphView).onChange(async (value) => {
      this.plugin.settings.enableGraphView = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u667A\u80FD\u6570\u5B66\u8F93\u5165").setDesc("\u542F\u7528\u6570\u5B66\u516C\u5F0F\u667A\u80FD\u8F93\u5165\u8F85\u52A9").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMathInput).onChange(async (value) => {
      this.plugin.settings.enableMathInput = value;
      await this.plugin.saveSettings();
    }));
  }
  addRecognitionSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u672F\u8BED\u8BC6\u522B\u8BBE\u7F6E" });
    new import_obsidian14.Setting(containerEl).setName("\u8BC6\u522B\u654F\u611F\u5EA6").setDesc("\u672F\u8BED\u8BC6\u522B\u7684\u654F\u611F\u5EA6 (0.1-1.0)").addSlider((slider) => slider.setLimits(0.1, 1, 0.1).setValue(this.plugin.settings.recognitionSensitivity).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.recognitionSensitivity = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u6BCF\u4E2A\u7B14\u8BB0\u6700\u5927\u672F\u8BED\u6570").setDesc("\u9650\u5236\u6BCF\u4E2A\u7B14\u8BB0\u4E2D\u8BC6\u522B\u7684\u6700\u5927\u672F\u8BED\u6570\u91CF").addText((text) => text.setPlaceholder("100").setValue(this.plugin.settings.maxTermsPerNote.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.maxTermsPerNote = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian14.Setting(containerEl).setName("\u81EA\u5B9A\u4E49\u672F\u8BED\u6587\u4EF6\u8DEF\u5F84").setDesc("\u6307\u5B9A\u81EA\u5B9A\u4E49\u6570\u5B66\u672F\u8BED\u8BCD\u5178\u6587\u4EF6\u7684\u8DEF\u5F84").addText((text) => text.setPlaceholder("\u4F8B\u5982: custom-terms.json").setValue(this.plugin.settings.customTermsPath).onChange(async (value) => {
      this.plugin.settings.customTermsPath = value;
      await this.plugin.saveSettings();
    }));
  }
  addGraphSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u77E5\u8BC6\u56FE\u8C31\u8BBE\u7F6E" });
    new import_obsidian14.Setting(containerEl).setName("\u56FE\u8C31\u5E03\u5C40").setDesc("\u9009\u62E9\u77E5\u8BC6\u56FE\u8C31\u7684\u5E03\u5C40\u7B97\u6CD5").addDropdown((dropdown) => dropdown.addOption("force", "\u529B\u5BFC\u5411\u5E03\u5C40").addOption("circular", "\u73AF\u5F62\u5E03\u5C40").addOption("hierarchical", "\u5C42\u6B21\u5E03\u5C40").setValue(this.plugin.settings.graphLayout).onChange(async (value) => {
      this.plugin.settings.graphLayout = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u663E\u793A\u8282\u70B9\u6807\u7B7E").setDesc("\u5728\u56FE\u8C31\u4E2D\u663E\u793A\u672F\u8BED\u540D\u79F0\u6807\u7B7E").addToggle((toggle) => toggle.setValue(this.plugin.settings.showLabels).onChange(async (value) => {
      this.plugin.settings.showLabels = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u8282\u70B9\u6700\u5C0F\u5C3A\u5BF8").setDesc("\u56FE\u8C31\u8282\u70B9\u7684\u6700\u5C0F\u663E\u793A\u5C3A\u5BF8").addText((text) => text.setPlaceholder("10").setValue(this.plugin.settings.nodeSize.min.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0 && num < this.plugin.settings.nodeSize.max) {
        this.plugin.settings.nodeSize.min = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian14.Setting(containerEl).setName("\u8282\u70B9\u6700\u5927\u5C3A\u5BF8").setDesc("\u56FE\u8C31\u8282\u70B9\u7684\u6700\u5927\u663E\u793A\u5C3A\u5BF8").addText((text) => text.setPlaceholder("50").setValue(this.plugin.settings.nodeSize.max.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > this.plugin.settings.nodeSize.min) {
        this.plugin.settings.nodeSize.max = num;
        await this.plugin.saveSettings();
      }
    }));
  }
  addLaTeXSettings(containerEl) {
    containerEl.createEl("h3", { text: "LaTeX\u8BBE\u7F6E" });
    new import_obsidian14.Setting(containerEl).setName("LaTeX\u6E32\u67D3\u5668").setDesc("\u9009\u62E9LaTeX\u516C\u5F0F\u7684\u6E32\u67D3\u5F15\u64CE").addDropdown((dropdown) => dropdown.addOption("obsidian", "Obsidian\u5185\u7F6E").addOption("mathjax", "MathJax").addOption("katex", "KaTeX").setValue(this.plugin.settings.latexRenderer).onChange(async (value) => {
      this.plugin.settings.latexRenderer = value;
      await this.plugin.saveSettings();
    }));
  }
  addAdvancedSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u9AD8\u7EA7\u8BBE\u7F6E" });
    new import_obsidian14.Setting(containerEl).setName("\u81EA\u52A8\u4FDD\u5B58\u95F4\u9694").setDesc("\u6570\u636E\u81EA\u52A8\u4FDD\u5B58\u7684\u65F6\u95F4\u95F4\u9694\uFF08\u6BEB\u79D2\uFF09").addText((text) => text.setPlaceholder("5000").setValue(this.plugin.settings.autoSaveInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.autoSaveInterval = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian14.Setting(containerEl).setName("\u8C03\u8BD5\u6A21\u5F0F").setDesc("\u542F\u7528\u8BE6\u7EC6\u7684\u8C03\u8BD5\u65E5\u5FD7\u8F93\u51FA").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDebugMode).onChange(async (value) => {
      this.plugin.settings.enableDebugMode = value;
      await this.plugin.saveSettings();
    }));
  }
  addShortcutSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u5FEB\u6377\u952E\u8BBE\u7F6E" });
    new import_obsidian14.Setting(containerEl).setName("\u6570\u5B66\u8F93\u5165\u6A21\u5F0F").setDesc("\u5207\u6362\u6570\u5B66\u8F93\u5165\u6A21\u5F0F\u7684\u5FEB\u6377\u952E").addText((text) => text.setPlaceholder("Ctrl+M").setValue(this.plugin.settings.shortcutKeys.toggleMathInput).onChange(async (value) => {
      this.plugin.settings.shortcutKeys.toggleMathInput = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u6253\u5F00\u56FE\u8C31\u89C6\u56FE").setDesc("\u6253\u5F00\u77E5\u8BC6\u56FE\u8C31\u89C6\u56FE\u7684\u5FEB\u6377\u952E").addText((text) => text.setPlaceholder("Ctrl+Shift+G").setValue(this.plugin.settings.shortcutKeys.openGraphView).onChange(async (value) => {
      this.plugin.settings.shortcutKeys.openGraphView = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("\u8BC6\u522B\u672F\u8BED").setDesc("\u624B\u52A8\u8BC6\u522B\u5F53\u524D\u6587\u6863\u672F\u8BED\u7684\u5FEB\u6377\u952E").addText((text) => text.setPlaceholder("Ctrl+Shift+R").setValue(this.plugin.settings.shortcutKeys.recognizeTerms).onChange(async (value) => {
      this.plugin.settings.shortcutKeys.recognizeTerms = value;
      await this.plugin.saveSettings();
    }));
  }
  addAboutSection(containerEl) {
    containerEl.createEl("h3", { text: "\u5173\u4E8E" });
    const aboutDiv = containerEl.createDiv();
    aboutDiv.innerHTML = `
			<p><strong>\u6570\u5B66\u8BB0\u5FC6\u56FE\u8C31\u63D2\u4EF6 v1.0.0</strong></p>
			<p>\u667A\u80FD\u8BC6\u522B\u4E2D\u6587\u6570\u5B66\u672F\u8BED\uFF0C\u6784\u5EFA\u4E2A\u4EBA\u5316\u6570\u5B66\u77E5\u8BC6\u56FE\u8C31</p>
			<p>\u63D0\u4F9BLaTeX\u8F6C\u6362\u548C\u667A\u80FD\u8F93\u5165\u8F85\u52A9\u529F\u80FD</p>
			<br>
			<p><strong>\u6838\u5FC3\u7279\u6027\uFF1A</strong></p>
			<ul>
				<li>\u81EA\u52A8\u8BC6\u522B\u4E2D\u6587\u6570\u5B66\u672F\u8BED</li>
				<li>\u52A8\u6001\u6784\u5EFA\u77E5\u8BC6\u56FE\u8C31</li>
				<li>LaTeX\u4EE3\u7801\u8F6C\u6362</li>
				<li>\u667A\u80FD\u8F93\u5165\u8F85\u52A9</li>
				<li>\u4E2A\u6027\u5316\u5B66\u4E60\u8BB0\u5F55</li>
			</ul>
		`;
  }
};
